{\rtf1\fbidis\ansi\ansicpg1252\deff0\nouicompat\deflang4105{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Calibri;}{\f2\fnil\fcharset178 Arial;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.10586}\viewkind4\uc1 
\pard\ltrpar\sa200\sl276\slmult1\f0\fs22\lang9 first change\par
Basics: All about Java threads\par
MULTITHREADING\par
What are Java Threads?\par
\par
A thread is a:\par
\par
Facility to allow multiple activities within a single process\par
Referred as lightweight process\par
A thread is a series of executed statements\par
Each thread has its own program counter, stack and local variables\par
A thread is a nested sequence of method calls\par
Its shares memory, files and per-process state\par
Read: Multithreading in Java\par
\par
Whats the need of a thread or why we use Threads?\par
To perform asynchronous or background processing\par
Increases the responsiveness of GUI applications\par
Take advantage of multiprocessor systems\par
Simplify program logic when there are multiple independent entities\par
What happens when a thread is invoked?\par
When a thread is invoked, there will be two paths of execution. One path will execute the thread and the other path will follow the statement after the thread invocation. There will be a separate stack and memory space for each thread.\par
\par
Risk Factor\par
Proper co-ordination is required between threads accessing common variables [use of synchronized and volatile] for consistence view of data\par
overuse of java threads can be hazardous to program\f1\rquote\f0 s performance and its maintainability.\par
Threads in Java\par
\par
Java threads facility and API is deceptively simple:\par
Every java program creates at least one thread [ main() thread ]. Additional threads are created through the Thread constructor or by instantiating classes that extend the Thread class.\par
\par
Thread creation in Java\par
Thread implementation in java can be achieved in two ways:\par
\par
Extending the java.lang.Thread class\par
Implementing the java.lang.Runnable Interface\par
Note: The Thread and Runnable are available in the   java.lang.* package\par
\par
1) By extending thread class\par
The class should extend Java Thread class.\par
The class should override the run() method.\par
The functionality that is expected by the Thread to be executed is written in the run() method.\par
void start(): Creates a new thread and makes it runnable.\par
void run(): The new thread begins its life inside this method.\par
\par
Example:\par
\par
public class MyThread extends Thread \{\par
   public void run()\{  \par
    System.out.println("thread is running...");  \par
  \} \par
   public static void main(String[] args) \{\par
     MyThread obj = new MyThread();\par
     obj.start();\par
\}\par
2) By Implementing Runnable interface\par
The class should implement the Runnable interface\par
The class should implement the run() method in the Runnable interface\par
The functionality that is expected by the Thread to be executed is put in the run() method\par
Example:\par
\par
public class MyThread implements Runnable \{\par
   public void run()\{  \par
     System.out.println("thread is running..");  \par
   \}  \par
   public static void main(String[] args) \{\par
     Thread t = new Thread(new MyThread());\par
     t.start();\par
\}\par
Extends Thread class vs Implements Runnable Interface?\par
\par
Extending the Thread class will make your class unable to extend other classes, because of the single inheritance feature in  JAVA. However, this will give you a simpler code structure. If you implement Runnable, you can gain better object-oriented design and consistency and also avoid the single inheritance problems.\par
If you just want to achieve basic functionality of a thread you can simply implement Runnable interface and override run() method. But if you want to do something serious with thread object as it has other methods like suspend(), resume(), ..etc which are not available in Runnable interface then you may prefer to extend the Thread class.\par
Thread life cycle in java\par
Read full article at: Thread life cycle in java\par
\par
Ending Thread\par
A Thread ends due to the following reasons:\par
\par
The thread ends when it comes when the run() method finishes its execution.\par
When the thread throws an Exception or Error that is not being caught in the program.\par
Java program completes or ends.\par
Another thread calls stop() methods.\par
Synchronization of Threads\par
In many cases concurrently running threads share data and two threads try to do operations on the same variables at the same time. This often results in corrupt data as two threads try to operate on the same data.\par
A popular solution is to provide some kind of lock primitive.  Only one thread can acquire a particular lock at any particular time. This can be achieved by using a keyword \f1\ldblquote\f0 synchronized\f1\rdblquote  \f0 .\par
By using the synchronize only one thread can access the method at a time and a second call will be blocked until the first call returns or wait() is called inside the synchronized method.\par
Deadlock\par
\par
Whenever there is multiple processes contending for exclusive access to multiple locks, there is the possibility of deadlock. A set of processes or threads is said to be deadlocked when each is waiting for an action that only one of the others can perform.\par
In Order to avoid deadlock, one should ensure that when you acquire multiple locks, you always acquire the locks in the same order in all threads.\par
\par
Guidelines for synchronization\par
Keep blocks short. Synchronized blocks should be short \f1\emdash  as short as possible while still protecting the integrity of related data operations.\par
Don\rquote t block. Don\rquote t ever call a method that might block, such as InputStream.read(), inside a synchronized block or method.\par
Don\rquote t invoke methods on other objects while holding a lock. This may sound extreme, but it eliminates the most common source of deadlock.\par
Target keywords: Java threads, javathread example, create thread java, java Runnable\f0\par
\par
\par
Multithreading in java with examples\par
MULTITHREADING\par
In this tutorial we will learn what is multithreaded environment? How to implement it in Java? and what are the advantages of doing so?\par
\par
The main purpose of multithreading is to provide simultaneous execution of two or more parts of a program to maximum utilize the CPU time. A multithreaded program contains two or more parts that can run concurrently. Each part of such a program called a thread. Each thread has a separate path of its execution. So this way a single program can perform two or more tasks simultaneously.\par
Threads are lightweight processes; they share the same address space. In Multithreaded environment, programs make maximum use of CPU so that the idle time can be kept to minimum.\par
Handling of multithreading in java is quite simple. We will learn that in this post.\par
There are several thread states, A thread can be in any one of the state at a particular point of time. It can be running state. It can be ready to run state as soon as it gets CPU time. A running thread can be suspended. A suspended thread can be resumed. A thread can be blocked when waiting for a resource. At any time a thread can be terminated.\par
Recommended Reads:\par
Java threads\par
Thread life cycle in Java\par
The Thread class and Runnable Interface\par
\par
A thread can be created in two ways: 1)By extending Thread class 2) By implementing Runnable interface.\par
Before we learn how to create the thread. Lets have a look at the methods that helps in managing the threads.\par
\par
getName(): It is used for Obtaining a thread\f1\rquote\f0 s name\par
getPriority(): Obtain a thread\f1\rquote\f0 s priority\par
isAlive(): Determine if a thread is still running\par
join(): Wait for a thread to terminate\par
run(): Entry point for the thread\par
sleep(): suspend a thread for a period of time\par
start(): start a thread by calling its run() method\par
Method 1: Thread creation by implementing Runnable Interface\par
\par
One way of creating a thread is to create a class that implements the Runnable interface. We must need to give the definition of run() method.\par
This run method is the entry point for the thread and thread will be alive till run method finishes its execution.\par
Once the thread is created it will start running when start() method gets called. Basically start() method calls run() method implicitly.\par
A Simple Example\par
\par
class MultithreadingDemo implements Runnable\{  \par
  public void run()\{  \par
    System.out.println("My thread is in running state.");  \par
  \}   \par
  public static void main(String args[])\{  \par
     MultithreadingDemo obj=new MultithreadingDemo();  \par
     Thread tobj =new Thread(obj);  \par
     tobj.start();  \par
 \}  \par
\}\par
Output:\par
\par
My thread is in running state.\par
Example Program 2:\par
Observe the output of this program and try to understand what is happening in this program. If you have understood the usage of each thread method then you would not face any issue, understanding this example.\par
\par
class Count implements Runnable\par
\{\par
   Thread mythread ;\par
   Count()\par
   \{ \par
      mythread = new Thread(this, "my runnable thread");\par
      System.out.println("my thread created" + mythread);\par
      mythread.start();\par
   \}\par
   public void run()\par
   \{\par
      try\par
      \{\par
        for (int i=0 ;i<10;i++)\par
        \{\par
          System.out.println("Printing the count " + i);\par
          Thread.sleep(1000);\par
        \}\par
     \}\par
     catch(InterruptedException e)\par
     \{\par
        System.out.println("my thread interrupted");\par
     \}\par
     System.out.println("mythread run is over" );\par
   \}\par
\}\par
class RunnableExample\par
\{\par
    public static void main(String args[])\par
    \{\par
       Count cnt = new Count();\par
       try\par
       \{\par
          while(cnt.mythread.isAlive())\par
          \{\par
            System.out.println("Main thread will be alive till the child thread is live"); \par
            Thread.sleep(1500);\par
          \}\par
       \}\par
       catch(InterruptedException e)\par
       \{\par
          System.out.println("Main thread interrupted");\par
       \}\par
       System.out.println("Main thread run is over" );\par
    \}\par
\}\par
Output:\par
\par
my thread createdThread[my runnable thread,5,main]\par
Main thread will be alive till the child thread is live\par
Printing the count 0\par
Printing the count 1\par
Main thread will be alive till the child thread is live\par
Printing the count 2\par
Main thread will be alive till the child thread is live\par
Printing the count 3\par
Printing the count 4\par
Main thread will be alive till the child thread is live\par
Printing the count 5\par
Main thread will be alive till the child thread is live\par
Printing the count 6\par
Printing the count 7\par
Main thread will be alive till the child thread is live\par
Printing the count 8\par
Main thread will be alive till the child thread is live\par
Printing the count 9\par
mythread run is over\par
Main thread run is over\par
Method 2: Thread creation by extending Thread class\par
\par
This is the second way of creating a thread. Here we need to create a new class that extends the Thread class.\par
The class should override the run() method which is the entry point for the new thread as described above.\par
Call start() method to start the execution of a thread.\par
We will explain this method by using the same above examples.\par
Example 1:\par
\par
class MultithreadingDemo extends Thread\{  \par
  public void run()\{  \par
    System.out.println("My thread is in running state.");  \par
  \}   \par
  public static void main(String args[])\{  \par
     MultithreadingDemo obj=new MultithreadingDemo();   \par
     obj.start();  \par
  \}  \par
\}\par
Output:\par
\par
My thread is in running state.\par
Example 2:\par
\par
class Count extends Thread\par
\{\par
   Count()\par
   \{\par
     super("my extending thread");\par
     System.out.println("my thread created" + this);\par
     start();\par
   \}\par
   public void run()\par
   \{\par
     try\par
     \{\par
        for (int i=0 ;i<10;i++)\par
        \{\par
           System.out.println("Printing the count " + i);\par
           Thread.sleep(1000);\par
        \}\par
     \}\par
     catch(InterruptedException e)\par
     \{\par
        System.out.println("my thread interrupted");\par
     \}\par
     System.out.println("My thread run is over" );\par
   \}\par
\}\par
class ExtendingExample\par
\{\par
   public static void main(String args[])\par
   \{\par
      Count cnt = new Count();\par
      try\par
      \{\par
         while(cnt.isAlive())\par
         \{\par
           System.out.println("Main thread will be alive till the child thread is live");\par
           Thread.sleep(1500);\par
         \}\par
      \}\par
      catch(InterruptedException e)\par
      \{\par
        System.out.println("Main thread interrupted");\par
      \}\par
      System.out.println("Main thread's run is over" );\par
   \}\par
\}\par
It would produce the same output which we have seen in the method 1 of implementing Runnable interface.\par
\par
Thread priorities\par
\par
Thread priorities are the integers which decide how one thread should be treated with respect to the others.\par
Thread priority decides when to switch from one running thread to another, process is called context switching\par
A thread can voluntarily release control and the highest priority thread that is ready to run is given the CPU.\par
A thread can be preempted by a higher priority thread no matter what the lower priority thread is doing. Whenever a higher priority thread wants to run it does.\par
To set the priority of the thread setPriority() method is used which is a method of the class Thread Class.\par
In place of defining the priority in integers, we can use MIN_PRIORITY, NORM_PRIORITY or MAX_PRIORITY.\par
Methods: isAlive() and join()\par
\par
In all the practical situations main thread should finish last else other threads which have spawned from the main thread will also finish.\par
To know whether the thread has finished we can call isAlive() on the thread which returns true if the thread is not finished.\par
Another way to achieve this by using join() method, this method when called from the parent thread makes parent thread wait till child thread terminates.\par
These methods are defined in the Thread class.\par
We have used isAlive() method in the above examples too.\par
Synchronization\par
\par
Multithreading introduces asynchronous behavior to the programs. If a thread is writing some data another thread may be reading the same data at that time. This may bring inconsistency.\par
When two or more threads need access to a shared resource there should be some way that the resource will be used only by one resource at a time. The process to achieve this is called synchronization.\par
To implement the synchronous behavior java has synchronous method. Once a thread is inside a synchronized method, no other thread can call any other synchronized method on the same object. All the other threads then wait until the first thread come out of the synchronized block.\par
When we want to synchronize access to objects of a class which was not designed for the multithreaded access and the code of the method which needs to be accessed synchronously is not available with us, in this case we cannot add the synchronized to the appropriate methods. In java we have the solution for this, put the calls to the methods (which needs to be synchronized) defined by this class inside a synchronized block in following manner.\par
Synchronized(object)\par
\{\par
    // statement to be synchronized\par
\}\par
Interthread Communication\par
\par
We have few methods through which java threads can communicate with each other. These methods are wait(), notify(), notifyAll(). All these methods can only be called from within a synchronized method.\par
1) To understand synchronization java has a concept of monitor. Monitor can be thought of as a box which can hold only one thread. Once a thread enters the monitor all the other threads have to wait until that thread exits the monitor.\par
2) wait()  tells the calling thread to give up the monitor and go to sleep until some other thread enters the same monitor and calls notify().\par
3) notify() wakes up the first thread that called wait() on the same object.\par
notifyAll() wakes up all the threads that called wait() on the same object. The highest priority thread will run first.\par
\par
References\par
\par
The Complete Reference Java 2 by Herbert Schildt\par
Target keywords: Multithreading in java, multithreading example in java,  programs that use multithreading,  java concurrency tutoria\par
\par
\par
\par
\par
\par
What are Java Threads?\par
\par
A thread is a:\par
\par
Facility to allow multiple activities within a single process\par
Referred as lightweight process\par
A thread is a series of executed statements\par
Each thread has its own program counter, stack and local variables\par
A thread is a nested sequence of method calls\par
Its shares memory, files and per-process state\par
Read: Multithreading in Java\par
\par
Whats the need of a thread or why we use Threads?\par
To perform asynchronous or background processing\par
Increases the responsiveness of GUI applications\par
Take advantage of multiprocessor systems\par
Simplify program logic when there are multiple independent entities\par
What happens when a thread is invoked?\par
When a thread is invoked, there will be two paths of execution. One path will execute the thread and the other path will follow the statement after the thread invocation. There will be a separate stack and memory space for each thread.\par
\par
Risk Factor\par
Proper co-ordination is required between threads accessing common variables [use of synchronized and volatile] for consistence view of data\par
overuse of java threads can be hazardous to program\f1\rquote\f0 s performance and its maintainability.\par
Threads in Java\par
\par
Java threads facility and API is deceptively simple:\par
Every java program creates at least one thread [ main() thread ]. Additional threads are created through the Thread constructor or by instantiating classes that extend the Thread class.\par
\par
Thread creation in Java\par
Thread implementation in java can be achieved in two ways:\par
\par
Extending the java.lang.Thread class\par
Implementing the java.lang.Runnable Interface\par
Note: The Thread and Runnable are available in the   java.lang.* package\par
\par
1) By extending thread class\par
The class should extend Java Thread class.\par
The class should override the run() method.\par
The functionality that is expected by the Thread to be executed is written in the run() method.\par
void start(): Creates a new thread and makes it runnable.\par
void run(): The new thread begins its life inside this method.\par
\par
Example:\par
\par
public class MyThread extends Thread \{\par
   public void run()\{  \par
    System.out.println("thread is running...");  \par
  \} \par
   public static void main(String[] args) \{\par
     MyThread obj = new MyThread();\par
     obj.start();\par
\}\par
2) By Implementing Runnable interface\par
The class should implement the Runnable interface\par
The class should implement the run() method in the Runnable interface\par
The functionality that is expected by the Thread to be executed is put in the run() method\par
Example:\par
\par
public class MyThread implements Runnable \{\par
   public void run()\{  \par
     System.out.println("thread is running..");  \par
   \}  \par
   public static void main(String[] args) \{\par
     Thread t = new Thread(new MyThread());\par
     t.start();\par
\}\par
Extends Thread class vs Implements Runnable Interface?\par
\par
Extending the Thread class will make your class unable to extend other classes, because of the single inheritance feature in  JAVA. However, this will give you a simpler code structure. If you implement Runnable, you can gain better object-oriented design and consistency and also avoid the single inheritance problems.\par
If you just want to achieve basic functionality of a thread you can simply implement Runnable interface and override run() method. But if you want to do something serious with thread object as it has other methods like suspend(), resume(), ..etc which are not available in Runnable interface then you may prefer to extend the Thread class.\par
Thread life cycle in java\par
Read full article at: Thread life cycle in java\par
\par
Ending Thread\par
A Thread ends due to the following reasons:\par
\par
The thread ends when it comes when the run() method finishes its execution.\par
When the thread throws an Exception or Error that is not being caught in the program.\par
Java program completes or ends.\par
Another thread calls stop() methods.\par
Synchronization of Threads\par
In many cases concurrently running threads share data and two threads try to do operations on the same variables at the same time. This often results in corrupt data as two threads try to operate on the same data.\par
A popular solution is to provide some kind of lock primitive.  Only one thread can acquire a particular lock at any particular time. This can be achieved by using a keyword \f1\ldblquote\f0 synchronized\f1\rdblquote  \f0 .\par
By using the synchronize only one thread can access the method at a time and a second call will be blocked until the first call returns or wait() is called inside the synchronized method.\par
Deadlock\par
\par
Whenever there is multiple processes contending for exclusive access to multiple locks, there is the possibility of deadlock. A set of processes or threads is said to be deadlocked when each is waiting for an action that only one of the others can perform.\par
In Order to avoid deadlock, one should ensure that when you acquire multiple locks, you always acquire the locks in the same order in all threads.\par
\par
Guidelines for synchronization\par
Keep blocks short. Synchronized blocks should be short \f1\emdash  as short as possible while still protecting the integrity of related data operations.\par
Don\rquote t block. Don\rquote t ever call a method that might block, such as InputStream.read(), inside a synchronized block or method.\par
Don\rquote t invoke methods on other objects while holding a lock. This may sound extreme, but it eliminates the most common source of deadlock.\par
Target keywords: Java threads, javathread example, create thread java, java Runnable\par
\par
\par
\par
\par
Thread life cycle in java and thread scheduling\par
MULTITHREADING\par
In previous post I have covered almost all the terms related to Java threads. Here we will learn Thread life cycle in java, we\rquote ll also see thread scheduling.\par
\par
Recommended Reads:\par
Multithreading in Java\par
\par
Thread Life cycle in Java\par
\par
The start method creates the system resources, necessary to run the thread, schedules the thread to run, and calls the thread\rquote s run method.\par
A thread becomes \ldblquote Not Runnable\rdblquote  when one of these events occurs:\par
If sleep method is invoked.\par
The thread calls the wait method.\par
The thread is blocking on I/O.\par
A thread dies naturally when the run method exits.\par
Below diagram clearly depicts the various phases of thread life cycle in java.\par
\par
thread life cycle in java\par
\par
2. Thread Scheduling\par
\par
Execution of multiple threads on a single CPU, in some order, is called scheduling.\par
In general, the runnable thread with the highest priority is active (running)\par
Java is priority-preemptive\par
If a high-priority thread wakes up, and a low-priority thread is running\par
Then the high-priority thread gets to run immediately\par
Allows on-demand processing\par
Efficient use of CPU\par
2.1 Types of scheduling\par
\par
Waiting and Notifying\par
Waiting [wait()] and notifying [notify(), notifyAll()] provides means of communication between threads that synchronize on the same object.\par
wait(): when wait() method is invoked on an object, the thread executing that code gives up its lock on the object immediately and moves the thread to the wait state.\par
notify(): This wakes up threads that called wait() on the same object and moves the thread to ready state.\par
notifyAll(): This wakes up all the threads that called wait() on the same object.\par
Running and Yielding\par
Yield() is used to give the other threads of the same priority a chance to execute i.e. causes current running thread to move to runnable state.\par
Sleeping and Waking up\par
nSleep() is used to pause a thread for a specified period of time i.e. moves the current running thread to Sleep state for a specified amount of time, before moving it to runnable state. Thread.sleep(no. of milliseconds);\par
2.2 Thread Priority\par
\par
When a Java thread is created, it inherits its priority from the thread that created it.\par
You can modify a thread\rquote s priority at any time after its creation using the setPriority method.\par
Thread priorities are integers ranging between MIN_PRIORITY (1) and MAX_PRIORITY (10) . The higher the integer, the higher the priority.Normally the thread priority will be 5.\par
2.3 isAlive() and join() methods\par
\par
isAlive() method is used to determine if a thread is still alive. It is the best way to determine if a thread has been started but has not yet completed its run() method. final boolean isAlive();\par
The nonstatic join() method of class Thread lets one thread \ldblquote join onto the end\rdblquote  of another thread. This method waits until the thread on which it is called terminates. final void join();\par
3. Blocking Threads\par
\par
When reading from a stream, if input is not available, the thread will block\par
Thread is suspended (\ldblquote blocked\rdblquote ) until I/O is available\par
Allows other threads to automatically activate\par
When I/O available, thread wakes back up again\par
Becomes \ldblquote runnable\rdblquote  i.e. gets into ready state\par
4. Grouping of threads\par
\par
Thread groups provide a mechanism for collecting multiple threads into a single object and manipulating those threads all at once, rather than individually.\par
To put a new thread in a thread group the group must\par
be explicitly specified when the thread is created\par
\endash  public Thread(ThreadGroup group, Runnable runnable)\par
\endash  public Thread(ThreadGroup group, String name)\par
\endash  public Thread(ThreadGroup group, Runnable runnable, String name)\par
A thread can not be moved to a new group after the thread has been created.\par
When a Java application first starts up, the Java runtime system creates a ThreadGroup named main.\par
Java thread groups are implemented by the java.lang.ThreadGroup class.\par
Target keywords: thread life cycle in java, java threading tutorial, using threads in java, javathread run.\par
\par
\par
Thread join() method in Java with example\par
MULTITHREADING\par
The join() method is used to hold the execution of currently running thread until the specified thread is dead(finished execution). In this tutorial we will discuss the purpose and use of join() method with examples.\par
\par
Why we use join() method?\par
\par
In normal circumstances we generally have more than one thread, thread scheduler schedules the threads, which does not guarantee the order of execution of threads.\par
For example lets have a look at the following code:\par
\par
Without using join()\par
\par
Here we have three threads th1, th2 and th3. Even though we have started the threads in a sequential manner the thread scheduler does not start and end them in the specified order. Everytime you run this code, you may get a different result each time. So the question is: How can we make sure that the threads executes in a particular order. The Answer is: By using join() method appropriately.\par
\par
public class JoinExample2 \{\par
   public static void main(String[] args) \{\par
      Thread th1 = new Thread(new MyClass2(), "th1");\par
      Thread th2 = new Thread(new MyClass2(), "th2");\par
      Thread th3 = new Thread(new MyClass2(), "th3");\par
         \par
      th1.start();\par
      th2.start();        \par
      th3.start();\par
   \}\par
\}\par
 \par
class MyClass2 implements Runnable\{\par
 \par
    @Override\par
    public void run() \{\par
    \tab Thread t = Thread.currentThread();\par
        System.out.println("Thread started: "+t.getName());\par
        try \{\par
            Thread.sleep(4000);\par
        \} catch (InterruptedException ie) \{\par
            ie.printStackTrace();\par
        \}\par
        System.out.println("Thread ended: "+t.getName());    \par
    \}\par
\}\par
Output:\par
\par
Thread started: th1\par
Thread started: th3\par
Thread started: th2\par
Thread ended: th1\par
Thread ended: th3\par
Thread ended: th2\par
Lets have a look at the another code where we are using the join() method.\par
\par
The same example with join()\par
\par
Lets say our requirement is to execute them in the order of first, second and third. We can do so by using join() method appropriately.\par
\par
public class JoinExample \{\par
   public static void main(String[] args) \{\par
      Thread th1 = new Thread(new MyClass(), "th1");\par
      Thread th2 = new Thread(new MyClass(), "th2");\par
      Thread th3 = new Thread(new MyClass(), "th3");\par
         \par
      // Start first thread immediately\par
      th1.start();\par
         \par
      /* Start second thread(th2) once first thread(th1) \par
       * is dead\par
       */\par
      try \{\par
          th1.join();\par
      \} catch (InterruptedException ie) \{\par
          ie.printStackTrace();\par
        \}\par
      th2.start();\par
         \par
      /* Start third thread(th3) once second thread(th2) \par
       * is dead\par
       */\par
      try \{\par
          th2.join();\par
      \} catch (InterruptedException ie) \{\par
           ie.printStackTrace();\par
        \}\par
      th3.start();\par
         \par
      // Displaying a message once third thread is dead\par
      try \{\par
          th3.join();\par
      \} catch (InterruptedException ie) \{\par
            ie.printStackTrace();\par
        \}  \par
      System.out.println("All three threads have finished execution");\par
   \}\par
\}\par
 \par
class MyClass implements Runnable\{\par
 \par
    @Override\par
    public void run() \{\par
    \tab Thread t = Thread.currentThread();\par
        System.out.println("Thread started: "+t.getName());\par
        try \{\par
            Thread.sleep(4000);\par
        \} catch (InterruptedException ie) \{\par
            ie.printStackTrace();\par
        \}\par
        System.out.println("Thread ended: "+t.getName());\par
        \par
    \}\par
\}\par
Output:\par
\par
Thread started: th1\par
Thread ended: th1\par
Thread started: th2\par
Thread ended: th2\par
Thread started: th3\par
Thread ended: th3\par
All three threads have finished execution\par
In this example we have used the join() method in such a way that our threads execute in the specified order.\par
\par
\par
\par
Why don\rquote t we call run() method directly, why call start() method?\par
MULTITHREADING\par
We can call run() method if we want but then it would behave just like a normal method and we would not be able to take the advantage of multithreading. When the run method gets called though start() method then a new separate thread is being allocated to the execution of run method, so if more than one thread calls start() method that means their run method is being executed by separate threads (these threads run simultaneously).\par
\par
On the other hand if the run() method of these threads are being called directly then the execution of all of them is being handled by the same current thread and no multithreading will take place, hence the output would reflect the sequential execution of threads in the specified order. Did it confuse you? Lets have a look at the below code to understand this situation.\par
\par
Calling run() method\par
\par
public class RunMethodExample implements Runnable\{\par
   public void run()\{  \par
      for(int i=1;i<=3;i++)\{  \par
\tab try\{\par
              Thread.sleep(1000);\par
\tab    \}catch(InterruptedException ie)\{\par
\tab\tab ie.printStackTrace();\par
\tab     \}  \par
\tab  System.out.println(i);  \par
      \}  \par
   \}  \par
   public static void main(String args[])\{  \par
      Thread th1 = new Thread(new RunMethodExample(), "th1");\par
      Thread th2 = new Thread(new RunMethodExample(), "th2"); \par
      th1.run();  \par
      th2.run(); \par
   \}\par
\}\par
Output:\par
\par
1\par
2\par
3\par
1\par
2\par
3\par
As you can observe in the output that multithreading didn\rquote t place here, it because both the run methods are being handled by the current thread. that treated them like normal methods and had them executed in the specified order rather then having them executed simultaneously. Thread scheduler didn\rquote t play any role here.\par
\par
Calling start() method\par
\par
Multithreading takes place and the output reflects simultaneous execution of threads.\par
\par
public class RunMethodExample2 \{\par
   public void run()\{  \par
      for(int i=1;i<=3;i++)\{  \par
\tab  try\{\par
               Thread.sleep(1000);\par
\tab  \}\par
         catch(InterruptedException ie)\{\par
\tab        ie.printStackTrace();\par
         \}  \par
         System.out.println(i);  \par
      \}  \par
   \}  \par
   public static void main(String args[])\{  \par
      Thread th1 = new Thread(new RunMethodExample(), "th1");\par
      Thread th2 = new Thread(new RunMethodExample(), "th2"); \par
      th1.start();  \par
      th2.start(); \par
   \}\par
\}\par
Output:\par
\par
1\par
1\par
2\par
2\par
3\par
3\par
As you can see the output reflects the simultaneous execution of threads.\par
\par
\par
\par
Can we start a Thread twice in Java?\par
MULTITHREADING\par
Can we start a thread twice in Java? The answer is no, once a thread is started, it can never be started again. Doing so will throw an IllegalThreadStateException. Lets have a look at the below code:\par
\par
public class ThreadTwiceExample implements Runnable \{\par
   @Override\par
   public void run()\{  \par
\tab Thread t = Thread.currentThread();\par
        System.out.println(t.getName()+" is executing.");\par
\tab\tab     \par
   \}  \par
   public static void main(String args[])\{  \par
\tab Thread th1 = new Thread(new ThreadTwiceExample(), "th1"); \par
\tab th1.start();  \par
\tab th1.start();  \par
   \} \par
\}\par
Output:\par
\par
Exception in thread "main" th1 is executing.\par
java.lang.IllegalThreadStateException\par
As you observe the first call to start() resulted in execution of run() method, however the exception got thrown when we tried to call the start() second time.\par
\par
You Might Like:\par
\par
Daemon thread in Java with example\par
Thread join() method in Java with example\par
Why don\rquote t we call run() method directly, why call start() method?\par
Thread life cycle in java and thread scheduling\par
Java Multithreading Interview Questions and Answers\par
What is the difference between a process and a thread in Java?\par
How to throw exception in java with example\par
Previous ArticleNext Article\par
\f0 2 comments\f1\'85 \f0 add one\f1\par
\par
juvin July 17, 2015, 2:23 AM\par
hello,\par
\f0 you are doing a very good job in clarifying the java basics for the newbies \f1\'85\par
please keep doing it more and more on more topics.. :) (greedy me :p )\par
\par
i have a doubt.\par
the same thread cannot be started multiple times. what if i instantiate the class again and then start it again?\par
ti = new ThreadclassName();\par
ti.start;\par
t2= new ThreadclassName();\par
t2.start();\par
\par
is this possible?\par
\par
Reply\par
Neeraj July 27, 2015, 2:24 PM\par
Hi Juvin,\par
It is possible if we instantiate same class again and invoke run method by start, the program will compile successful.Now we are not running same thread.\par
\par
ava Multithreading Interview Questions and Answers\par
 JAVA Q&A\par
Earlier I have shared 100+ core java interview questions based on various topics of core java. In this article I am gonna share interview questions based on multithreading and concurrency only. You would face multithreading questions in almost all the interviews as this is one the frequently asked topic during interviews for java professionals.\par
\par
If you are new to this topic, I would recommend you to refer this tutorial (java multithreading) before going through the below set of interview questions and answers.\par
\par
Interview Questions on Multithreading\par
\par
Q) What is thread in Java?\par
A) A Thread is a concurrent unit of execution. Or in other words you can say that it is part of process that can run concurrently with other parts of the process.\par
\par
Q) What is Multithreading?\par
A) The process of executing multiple threads simultaneously is known as multithreading. Java supports multithreading. The main advantage of multithreading is reducing CPU idle time and improving the CPU utilization. This makes the job to be completed in less time.\par
\par
Q) What is the difference between thread and Process?\par
A) Refer this article: Thread vs Process\par
\par
Q) What are the two ways of creating a thread?\par
A) We can create a thread by using any of the two following methods.\par
1) By implementing Runnable interface\par
2) By extending Thread class\par
\par
Q) What is a Daemon thread?\par
A) Refer this article: Deamon thread in Java\par
\par
Q) How to make a thread (user thread) to Daemon thread?\par
A) By calling setDaemon() method we can make a user thread to daemon thread.\par
Syntax:\par
thread.setDaemon(true);\par
\par
Q) What is difference between user thread and Daemon thread?\par
A) By default a thread created in a program is always a user thread, however we can make it daemon by calling setDaemon(true) method, if needed. A daemon thread runs in a background and it doesn\rquote t prevent JVM from being shutdown. Once all the user thread gets completed the JVM shutdowns without being bothered whether a daemon thread is running or not.\par
\par
Q) Can we change a user thread to deamon thread by calling setDaemon() method if the thread has already been started?\par
No, if the thread has been started then we cannot make it daemon because it would then throw an IllegalThreadStateException\par
\par
Q) Can we call run() method of Thread class?\par
A) We can call run() method if we want but then it would behave just like a normal method and we would not be able to take the advantage of multithreading. In general run() methods starts execution when we call start() method of a Thread class. For more details on this: Refer this article.\par
\par
Q) What is deadlock?\par
A) A deadlock is a condition when two or more threads are in waiting for each other to release the resources that they need. For example Thread A holds a resource X and need resource Y whereas Thread B holds a resource Y and need X, in this case both threads are waiting for each other to release the resource and are in blocked condition.\par
\par
Q) What is synchronization?\par
A) It is a technique of granting access to the shared resources in multithread environment to avoid inconsistencies in the results.\par
\par
Q) What is the difference between notify() and notifyAll()?\par
A) notify() wakes up the first thread that called wait() on the same object, whereas the notifyAll() method wakes up all the waiting threads.\par
\par
Q) What does join() method do?\par
A) The join() method is used to hold the execution of currently running thread until the specified thread is dead(finished execution).\par
Read more about join() here.\par
\par
Q) Can we start a thread twice in Java?\par
No, once a thread is started, it can never be started again. Doing so will throw an illegalThreadStateException. For example: Refer this article.\par
\par
\par
\par
\par
\par
\par
\par
Exception handling in java with example programs\par
EXCEPTION HANDLING\par
In this tutorial we will discuss what is an exception and how it can be handled in java programming language.\par
\par
What is an exception?\par
\par
An Exception can be anything which interrupts the normal flow of the program. When an exception occurs program processing gets terminated and doesn\rquote t continue further. In such cases we get a system generated error message. The good thing about exceptions is that they can be handled. We will cover the handling part later in this same tutorial.\par
\par
When an exception can occur?\par
Exception can occur at runtime (known as runtime exceptions) as well as at compile-time (known Compile-time exceptions).\par
\par
Reasons for Exceptions\par
There can be several reasons for an exception. For example, following situations can cause an exception \endash  Opening a non-existing file, Network connection problem, Operands being manipulated are out of prescribed ranges, class file missing which was supposed to be loaded and so on.\par
\par
Difference between error and exception\par
\par
Errors indicate serious problems and abnormal conditions that most applications should not try to handle. Error defines problems that are not expected to be caught under normal circumstances by our program. For example memory error, hardware error, JVM error etc.\par
Exceptions are conditions within the code. A developer can handle such conditions and take necessary corrective actions. Few examples \endash\par
\par
DivideByZero exception\par
NullPointerException\par
ArithmeticException\par
ArrayIndexOutOfBoundsException\par
Advantages of Exception Handling\par
\par
Exception handling allows us to control the normal flow of the program by using exception handling in program.\par
It throws an exception whenever a calling method encounters an error providing that the calling method takes care of that error.\par
It also gives us the scope of organizing and differentiating between different error types using a separate block of codes. This is done with the help of try-catch blocks.\par
Why to handle exception?\par
If an exception is raised, which has not been handled by programmer then program execution can get terminated and system prints a non user friendly error message.\par
\par
Ex:-Take a look at the below system generated exception\par
\par
An exception generated by the system is given below\par
\par
 Exception in thread "main" java.lang.ArithmeticException: / by zero at ExceptionDemo.main(ExceptionDemo.java:5)\par
 ExceptionDemo : The class name\par
 main : The method name\par
 ExceptionDemo.java : The filename\par
 java:5 : Line number\par
For a novice user the above message won\rquote t be easy to understand. In order to let them know that what went wrong we use exception handling in java program. We handle such conditions and then prints a user friendly warning message to user, which lets them correct the error as most of the time exception occurs due to bad data provided by user.\par
\par
Types of exceptions\par
\par
There are two types of exceptions\par
\par
1)Checked exceptions\par
2)Unchecked exceptions\par
\par
Below is a brief about each however if you want a detailed tutorial with examples then you can refer Checked and Unchecked exceptions in Java.\par
\par
Checked exceptions\par
All exceptions other than Runtime Exceptions are known as Checked exceptions as the compiler checks them during compilation to see whether the programmer has handled them or not. If these exceptions are not handled/declared in the program, it will give compilation error.\par
\par
Examples of Checked Exceptions :-\par
ClassNotFoundException\par
IllegalAccessException\par
NoSuchFieldException\par
EOFException etc.\par
\par
Unchecked Exceptions\par
Runtime Exceptions are also known as Unchecked Exceptions as the compiler do not check whether the programmer has handled them or not but it\rquote s the duty of the programmer to handle these exceptions and provide a safe exit.\par
These exceptions need not be included in any method\rquote s throws list because compiler does not check to see if a method handles or throws these exceptions.\par
\par
Examples of Unchecked Exceptions:-\par
ArithmeticException\par
ArrayIndexOutOfBoundsException\par
NullPointerException\par
NegativeArraySizeException etc.\par
Exception hierarchy\par
Exception classes Hierarchy\par
Exception handling in Java\par
\par
Here are the list of tutorials which will help you understand the exception handling part in detail. Read them in the given sequence to grasp the concepts easily.\par
\par
Try Catch in Java \endash  Exception handling\par
EXCEPTION HANDLING\par
What is Try Block?\par
\par
The try block contains a block of program statements within which an exception might occur. A try block is always followed by a catch block, which handles the exception that occurs in associated try block. A try block must followed by a Catch block or Finally block or both.\par
\par
Syntax of try block\par
try\{\par
   //statements that may cause an exception\par
\}\par
What is Catch Block?\par
\par
A catch block must be associated with a try block. The corresponding catch block executes if an exception of a particular type occurs within the try block. For example if an arithmetic exception occurs in try block then the statements enclosed in catch block for arithmetic exception executes.\par
\par
Syntax of try catch in java\par
try\par
\{\par
     //statements that may cause an exception\par
\}\par
catch (exception(type) e(object))\f2\rtlch\lang1025\rtlmark\f0\ltrch\lang1033\par
\{\par
     //error handling code\par
\}\par
Flow of try catch block\par
If an exception occurs in try block then the control of execution is passed to the catch block from try block. The exception is caught up by the corresponding catch block. A single try block can have multiple catch statements associated with it, but each catch block can be defined for only one exception class. The program can also contain nested try-catch-finally blocks.\par
After the execution of all the try blocks, the code inside the finally block executes. It is not mandatory to include a finally block at all, but if you do, it will run regardless of whether an exception was thrown and handled by the try and catch blocks.\par
An example of Try catch in Java\par
class Example1 \{\par
   public static void main(String args[]) \{\par
     int num1, num2;\par
     try \{ \par
        // Try block to handle code that may cause exception\par
        num1 = 0;\par
        num2 = 62 / num1;\par
        System.out.println("Try block message");\par
     \} catch (ArithmeticException e) \{ \par
            // This block is to catch divide-by-zero error\par
            System.out.println("Error: Don't divide a number by zero");\par
       \}\par
     System.out.println("I'm out of try-catch block in Java.");\par
   \}\par
\}\par
Output:\par
\par
Error: Don't divide a number by zero\par
I'm out of try-catch block in Java.\par
Multiple catch blocks in Java\par
1. A try block can have any number of catch blocks.\par
2. A catch block that is written for catching the class Exception can catch all other exceptions\par
Syntax:\par
\par
catch(Exception e)\{\par
  //This catch block catches all the exceptions\par
\}\par
3. If multiple catch blocks are present in a program then the above mentioned catch block should be placed at the last as per the exception handling best practices.\par
4. If the try block is not throwing any exception, the catch block will be completely ignored and the program continues.\par
5. If the try block throws an exception, the appropriate catch block (if one exists) will catch it\par
\f1\endash\f0 catch(ArithmeticException e) is a catch block that can catch ArithmeticException\par
\f1\endash\f0 catch(NullPointerException e) is a catch block that can catch NullPointerException\par
6. All the statements in the catch block will be executed and then the program continues.\par
\par
Example of Multiple catch blocks\par
class Example2\{\par
   public static void main(String args[])\{\par
     try\{\par
         int a[]=new int[7];\par
         a[4]=30/0;\par
         System.out.println("First print statement in try block");\par
     \}\par
     catch(ArithmeticException e)\{\par
        System.out.println("Warning: ArithmeticException");\par
     \}\par
     catch(ArrayIndexOutOfBoundsException e)\{\par
        System.out.println("Warning: ArrayIndexOutOfBoundsException");\par
     \}\par
     catch(Exception e)\{\par
        System.out.println("Warning: Some Other exception");\par
     \}\par
   System.out.println("Out of try-catch block...");\par
  \}\par
\}\par
Output:\par
\par
Warning: ArithmeticException\par
Out of try-catch block...\par
In the above example there are multiple catch blocks and these catch blocks executes sequentially when an exception occurs in try block. Which means if you put the last catch block ( catch(Exception e)) at the first place, just after try block then in case of any exception this block will execute as it has the ability to handle all exceptions. This catch block should be placed at the last to avoid such situations.\par
\par
If you have any queries regarding try catch in Java, feel free to drop a comment below. I\f1\rquote\f0 ll get back to you ASAP.\par
\par
\par
Checked and unchecked exceptions in java with examples\par
EXCEPTION HANDLING\par
There are two types of exceptions: checked exceptions and unchecked exceptions. In this tutorial we will learn both of them with the help of examples. The main difference between checked and unchecked exception is that the checked exceptions are checked at compile-time while unchecked exceptions are checked at runtime.\par
\par
What are checked exceptions?\par
\par
Checked exceptions are checked at compile-time. It means if a method is throwing a checked exception then it should handle the exception using try-catch block or it should declare the exception using throws keyword, otherwise the program will give a compilation error. It is named as checked exception because these exceptions are checked at Compile time.\par
\par
Lets understand this with this example: In this example we are reading the file myfile.txt and displaying its content on the screen. In this program there are three places where an checked exception is thrown as mentioned in the comments below. FileInputStream which is used for specifying the file path and name, throws FileNotFoundException. The read() method which reads the file content throws IOException and the close() method which closes the file input stream also throws IOException.\par
\par
import java.io.*;\par
class Example \{  \par
   public static void main(String args[]) \par
   \{\par
\tab FileInputStream fis = null;\par
\tab /*This constructor FileInputStream(File filename)\par
\tab  * throws FileNotFoundException which is a checked\par
\tab  * exception*/\par
        fis = new FileInputStream("B:/myfile.txt"); \par
\tab int k; \par
\par
\tab /*Method read() of FileInputStream class also throws \par
\tab  * a checked exception: IOException*/\par
\tab while(( k = fis.read() ) != -1) \par
\tab\{ \par
\tab\tab System.out.print((char)k); \par
\tab\} \par
\par
\tab /*The method close() closes the file input stream\par
\tab  * It throws IOException*/\par
\tab fis.close(); \tab\par
   \}\par
\}\par
Output:\par
\par
Exception in thread "main" java.lang.Error: Unresolved compilation problems: \par
Unhandled exception type FileNotFoundException\par
Unhandled exception type IOException\par
Unhandled exception type IOException\par
Why this compilation error? As I mentioned in the beginning that checked exceptions gets checked during compile time. Since we didn\f1\rquote\f0 t handled/declared the exceptions, our program gave the compilation error.\par
How to resolve the error? There are two ways to avoid this error. We will see both the ways one by one.\par
\par
Method 1: Declare the exception using throws keyword.\par
As we know that all three occurrences of checked exceptions are inside main() method so one way to avoid the compilation error is: Declare the exception in the method using throws keyword. You may be thinking that our code is throwing FileNotFoundException and IOException both then why we are declaring the IOException alone. Th reason is that IOException is a parent class of FileNotFoundException so it by default covers that. If you want you can declare that too like this public static void main(String args[]) throws IOException, FileNotFoundException.\par
\par
import java.io.*;\par
class Example \{  \par
   public static void main(String args[]) throws IOException\par
   \{\par
      FileInputStream fis = null;\par
      fis = new FileInputStream("B:/myfile.txt"); \par
      int k; \par
\par
      while(( k = fis.read() ) != -1) \par
      \{ \par
\tab    System.out.print((char)k); \par
      \} \par
      fis.close(); \tab\par
   \}\par
\}\par
Output:\par
File content is displayed on the screen.\par
\par
Method 2: Handle them using try-catch blocks.\par
\par
The above approach is not good at all. It is not a best exception handling practice. You should give meaningful message for each exception type so that it would be easy for someone to understand the error. The code should be like this:\par
\par
import java.io.*;\par
class Example \{  \par
   public static void main(String args[])\par
   \{\par
\tab FileInputStream fis = null;\par
\tab try\{\par
\tab     fis = new FileInputStream("B:/myfile.txt"); \par
\tab\}catch(FileNotFoundException fnfe)\{\par
            System.out.println("The specified file is not " +\par
\tab\tab\tab "present at the given path");\par
\tab  \}\par
\tab int k; \par
\tab try\{\par
\tab     while(( k = fis.read() ) != -1) \par
\tab     \{ \par
\tab\tab System.out.print((char)k); \par
\tab     \} \par
\tab     fis.close(); \par
\tab\}catch(IOException ioe)\{\par
\tab     System.out.println("I/O error occurred: "+ioe);\par
\tab  \}\par
   \}\par
\}\par
This code will run fine and will display the file content.\par
\par
Here are the few other Checked Exceptions \f1\endash\f0\par
\par
SQLException\par
IOException\par
DataAccessException\par
ClassNotFoundException\par
InvocationTargetException\par
What are Unchecked exceptions?\par
\par
Unchecked exceptions are not checked at compile time. It means if your program is throwing an unchecked exception and even if you didn\f1\rquote\f0 t handle/declare that exception, the program won\f1\rquote\f0 t give a compilation error. Most of the times these exception occurs due to the bad data provided by user during the user-program interaction. It is up to the programmer to judge the conditions in advance, that can cause such exceptions and handle them appropriately. All Unchecked exceptions are direct sub classes of RuntimeException class.\par
\par
Lets understand this with an example:\par
\par
class Example \{  \par
   public static void main(String args[])\par
   \{\par
\tab int num1=10;\par
\tab int num2=0;\par
\tab /*Since I'm dividing an integer with 0\par
\tab  * it should throw ArithmeticException*/\par
\tab int res=num1/num2;\par
\tab System.out.println(res);\par
   \}\par
\}\par
If you compile this code, it would compile successfully however when you will run it, it would throw ArithmeticException. That clearly shows that unchecked exceptions are not checked at compile-time, they are being checked at runtime. Lets see another example.\par
\par
class Example \{  \par
   public static void main(String args[])\par
   \{\par
\tab int arr[] =\{1,2,3,4,5\};\par
\tab /*My array has only 5 elements but\par
\tab  * I'm trying to display the value of \par
\tab  * 8th element. It should throw\par
\tab  * ArrayIndexOutOfBoundsException*/\par
\tab System.out.println(arr[7]);\par
   \}\par
\}\par
This code would also compile successfully since ArrayIndexOutOfBoundsException is also an unchecked exception.\par
Note: It doesn\f1\rquote\f0 t mean that compiler is not checking these exceptions so we shouldn\f1\rquote\f0 t handle them. In fact we should handle them more carefully. For e.g. In the above example there should be a exception message to user that they are trying to display a value which doesn\f1\rquote\f0 t exist in array so that user would be able to correct the issue.\par
\par
class Example \{  \par
\tab public static void main(String args[])\par
\tab\{\par
\tab\tab try\{\par
\tab\tab int arr[] =\{1,2,3,4,5\};\par
\tab\tab System.out.println(arr[7]);\par
\tab\tab\}catch(ArrayIndexOutOfBoundsException e)\{\par
\tab\tab\tab System.out.println("The specified index does not exist " +\par
\tab\tab\tab\tab\tab "in array. Please correct the error.");\par
\tab\tab\}\par
\tab\}\par
\}\par
Here are the few most frequently seen unchecked exceptions \f1\endash\f0\par
\par
NullPointerException\par
ArrayIndexOutOfBoundsException\par
ArithmeticException\par
IllegalArgumentException\par
\par
\par
Nested try catch: Java exception handling\par
EXCEPTION HANDLING\par
The try catch blocks can be nested. One try-catch block can be present in the another try\f1\rquote\f0 s body. This is called Nesting of try catch blocks. Each time a try block does not have a catch handler for a particular exception, the stack is unwound and the next try block\f1\rquote\f0 s catch (i.e., parent try block\f1\rquote\f0 s catch) handlers are inspected for a match.\par
\par
If no catch block matches, then the java run-time system will handle the exception. Lets see the syntax first then we will discuss this with an example.\par
\par
Syntax of Nested try Catch\par
\par
....\par
//Main try block\par
try\par
\{\par
   statement 1;\par
   statement 2;\par
   //try-catch block inside another try block\par
   try\par
   \{\par
      statement 3;\par
      statement 4;\par
   \}\par
   catch(Exception e1)\par
   \{\par
       //Exception Message\par
   \}\par
   //try-catch block inside another try block\par
   try\par
   \{\par
       statement 5;\par
       statement 6;\par
   \}\par
   catch(Exception e2)\par
   \{\par
       //Exception Message\par
   \}\par
\}\par
catch(Exception e3) //Catch of Main(parent) try block\par
\{\par
      //Exception Message\par
\}\par
....\par
Nested try catch example \f1\endash  \f0 explanation\par
\par
class Nest\{\par
   public static void main(String args[])\{\par
\tab  //Parent try block\par
     try\{\par
    \tab //Child try block1\par
         try\{\par
            System.out.println("Inside block1");\par
            int b =45/0;\par
            System.out.println(b);\par
         \}\par
         catch(ArithmeticException e1)\{\par
            System.out.println("Exception: e1");\par
         \}\par
         //Child try block2\par
         try\{\par
            System.out.println("Inside block2");\par
            int b =45/0;\par
            System.out.println(b);\par
         \}\par
         catch(ArrayIndexOutOfBoundsException e2)\{\par
            System.out.println("Exception: e2");\par
         \}\par
        System.out.println("Just other statement");\par
    \}\par
    catch(ArithmeticException e3)\{\par
    \tab  System.out.println("Arithmetic Exception");\par
         System.out.println("Inside parent try catch block");\par
    \}\par
    catch(ArrayIndexOutOfBoundsException e4)\{\par
    \tab System.out.println("ArrayIndexOutOfBoundsException");\par
         System.out.println("Inside parent try catch block");\par
    \}\par
    catch(Exception e5)\{\par
    \tab System.out.println("Exception");\par
         System.out.println("Inside parent try catch block");\par
     \}\par
     System.out.println("Next statement..");\par
  \}\par
\}\par
Output:\par
\par
Inside block1\par
Exception: e1\par
Inside block2\par
Arithmetic Exception\par
Inside parent try catch block\par
Next statement..\par
The above example shows Nested try catch use in Java. You can see that there are two try-catch block inside main try block\f1\rquote\f0 s body. I\f1\rquote\f0 ve marked them as block 1 and block 2 in above example.\par
Block1:  I have divided an integer by zero and it caused an arithmetic exception however the catch of block1 is handling arithmetic exception so "Exception: e1" got printed.\par
\par
Block2: In block2 also, ArithmeticException occurred but block 2 catch is only handling ArrayIndexOutOfBoundsException so in this case control jump back to Main try-catch(parent) body. Since catch of parent try block is handling this exception that\f1\rquote\f0 s why \f1\ldblquote\f0 Inside parent try catch block\f1\rdblquote  \f0 got printed as output.\par
\par
Parent try Catch block: Since all the exception handled properly so program control didn\f1\rquote\f0 t get terminated at any point and at last \f1\ldblquote\f0 Next statement..\f1\rdblquote  \f0 came as output.\par
\par
Note: The main point to note here is that whenever the child try-catch blocks are not handling any exception, the control comes back to the parent try-catch if the exception is not handled there also then the program will terminate abruptly.\par
\par
Consider this example:\par
Here we have deep (two level) nesting which means we have a try-catch block inside a child try block. To make you understand better I have given the names to each try block in comments like try-block2 etc.\par
\par
This is how the structure is: try-block3 is inside try-block2 and try-block2 is inside main try-block, you can say that the main try-block is a grand parent of the try-block3. Refer the explanation which is given at the end of this code.\par
\par
class NestingDemo\{\par
   public static void main(String args[])\{\par
      //main try-block\par
      try\{\par
    \tab //try-block2\par
        try\{     \par
            //try-block3\par
            try\{\par
            \tab int arr[]= \{1,2,3,4\};\par
            \tab /* I'm trying to display the value of\par
            \tab  * an element which doesn't exist. The\par
            \tab  * code should throw an exception\par
            \tab  */\par
            \tab System.out.println(arr[10]);\par
            \}catch(ArithmeticException e)\{\par
            \tab System.out.print("Arithmetic Exception");\par
            \tab System.out.println(" handled in try-block3");\par
            \}\par
        \}\par
        catch(ArithmeticException e)\{\par
           System.out.print("Arithmetic Exception");\par
           System.out.println(" handled in try-block2");\par
        \}\par
    \}\par
    catch(ArithmeticException e3)\{\par
    \tab System.out.print("Arithmetic Exception");\par
     \tab System.out.println(" handled in main try-block");\par
    \}\par
    catch(ArrayIndexOutOfBoundsException e4)\{\par
    \tab System.out.print("ArrayIndexOutOfBoundsException");\par
     \tab System.out.println(" handled in main try-block");\par
    \}\par
    catch(Exception e5)\{\par
    \tab System.out.print("Exception");\par
     \tab System.out.println(" handled in main try-block");\par
     \}\par
  \}\par
\}\par
Output:\par
\par
ArrayIndexOutOfBoundsException handled in main try-block\par
As you can see that the ArrayIndexOutOfBoundsException has occurred in the grand child try-block3. Since try-block3 is not handling this exception, the control then gets transferred to the parent try-block2 and looked for the catch handlers in try-block2. Since the try-block2 is also not handling that exception, the control got transferred to the main grand parent try-block where it found the appropriate catch block for exception. This is how the routing of exception is done in nested structure.\par
\par
\par
Java Finally block \f1\endash  \f0 Exception handling\par
EXCEPTION HANDLING\par
What is Finally Block\par
\par
1. A finally statement must be associated with a try statement. It identifies a block of statements that needs to be executed regardless of whether or not an exception occurs within the try block.\par
\par
2. After all other try-catch processing is complete, the code inside the finally block executes. It is not mandatory to include a finally block at all, but if you do, it will run regardless of whether an exception was thrown and handled by the try and catch parts of the block.\par
\par
3. In normal execution the finally block is executed after try block. When any exception occurs first the catch block is executed and then finally block is executed.\par
\par
4. An exception in the finally block, exactly behaves like any other exception.\par
\par
5. The code present in the finally block executes even if the try or catch block contains control transfer statements like return, break or continue.\par
\par
To understand above concepts better refer the below examples.\par
\par
Syntax of Finally block\par
try\par
\{\par
    //statements that may cause an exception\par
\}\par
finally\par
\{\par
   //statements to be executed\par
\}\par
Cases when the finally block doesn\f1\rquote\f0 t execute\par
The circumstances that prevent execution of the code in a finally block are:\par
\f1\endash  \f0 The death of a Thread\par
\f1\endash  \f0 Using of the System. exit() method.\par
\f1\endash  \f0 Due to an exception arising in the finally block.\par
\par
Finally block and Return statement\par
Finally block executes even if there is a return statement in try-catch block. PFB the example \f1\endash\f0\par
\par
class JavaFinally\par
\{\par
   public static void main(String args[])\par
   \{\par
      System.out.println(JavaFinally.myMethod());  \par
   \}\par
   public static int myMethod()\par
   \{\par
      try \{\par
        return 112;\par
      \}\par
      finally \{\par
        System.out.println("This is Finally block");\par
        System.out.println("Finally block ran even after return statement");\par
      \}\par
   \}\par
\}\par
Output of above program:\par
\par
This is Finally block\par
Finally block ran even after return statement\par
112\par
Finally and Close()\par
Close() is generally used to close all the open streams in one go. Its a good practice to use close() inside finally block. Since finally block executes even if exception occurs so you can be sure that all input and output streams are closed properly regardless of whether the exception occurs or not.\par
\par
E.g.\par
\par
....\par
try\{ \par
    OutputStream osf = new FileOutputStream( "filename" );\par
    OutputStream osb = new BufferedOutputStream(opf);\par
    ObjectOutput op = new ObjectOutputStream(osb);\par
    try\{\par
       output.writeObject(writableObject);\par
    \}\par
    finally\{\par
       op.close();\par
    \}\par
\}\par
catch(IOException e1)\{\par
     System.out.println(e1);\par
\}\par
...\par
Finally block without catch\par
A try-finally block is possible without catch block. Which means a try block can be used with finally without having a catch block.\par
\par
...\par
InputStream input = null;\par
try \{\par
    input = new FileInputStream("inputfile.txt");\par
\} \par
finally \{\par
    if (input != null) \{\par
       try \{\par
         in.close();\par
       \}catch (IOException exp) \{\par
           System.out.println(exp);\par
        \}\par
    \}\par
\}\par
...\par
Finally block and System.exit()\par
System.exit() statement behaves differently than return statement. Unlike return statement whenever System.exit() gets called in try block then Finally block doesn\f1\rquote\f0 t get executed. Refer the below example to understand it better \f1\endash\f0\par
\par
....\par
try \{\par
   //try block\par
   System.out.println("Inside try block");\par
   System.exit(0)\par
\}\par
catch (Exception exp) \{\par
   System.out.println(exp);\par
\}\par
finally \{\par
   System.out.println("Java finally block");\par
\}\par
....\par
In the above example if the System.exit(0) gets called without any exception then finally won\f1\rquote\f0 t execute. However if any exception occurs while calling System.exit(0) then finally block will be executed.\par
\par
Handling try-catch-finally block\par
Either a try statement should be associated with a catch block or with finally.\par
Since catch performs exception handling and finally performs the cleanup, the best approach is to merge both of them.\par
Syntax:\par
\par
try\par
\{\par
     //statements that may cause an exception\par
\}\par
catch (\f1\'85\f0 )\f2\rtlch\lang1025\rtlmark\f0\ltrch\lang1033\par
\{\par
     //error handling code\par
\}\par
finally\par
\{\par
    //statements to be executed\par
\}\par
Examples of Try catch finally blocks\par
Example 1: Below example illustrates finally block when no exception occurs in try block\par
\par
class Example1\{\par
  public static void main(String args[])\{\par
    try\{\par
       System.out.println("First statement of try block");\par
       int num=45/3;\par
       System.out.println(num);\par
    \}\par
    catch(ArrayIndexOutOfBoundsException e)\{\par
       System.out.println("ArrayIndexOutOfBoundsException");\par
    \}\par
    finally\{\par
       System.out.println("finally block");\par
    \}\par
    System.out.println("Out of try-catch-finally block");\par
  \}\par
\}\par
Output:\par
\par
finally block\par
Out of try-catch-finally block\par
Example 2:Below example illustrates finally block execution when exception occurs in try block but doesn\f1\rquote\f0 t get handled in catch block.\par
\par
class Example2\{\par
   public static void main(String args[])\{\par
     try\{\par
        System.out.println("First statement of try block");\par
        int num=45/0;\par
        System.out.println(num);\par
     \}\par
     catch(ArrayIndexOutOfBoundsException e)\{\par
        System.out.println("ArrayIndexOutOfBoundsException");\par
     \}\par
     finally\{\par
        System.out.println("finally block");\par
     \}\par
     System.out.println("Out of try-catch-finally block");\par
   \}\par
\}\par
Output:\par
\par
First statement of try block\par
finally block\par
Exception in thread "main" java.lang.ArithmeticException: / by zero\par
\tab at beginnersbook.com.Example2.main(Details.java:6)\par
Example 3:Below example illustrates execution of finally, when exception occurs in try block and handled in catch block.\par
\par
class Example3\{\par
   public static void main(String args[])\{\par
      try\{\par
         System.out.println("First statement of try block");\par
         int num=45/0;\par
         System.out.println(num);\par
      \}\par
      catch(ArithmeticException e)\{\par
         System.out.println("ArithmeticException");\par
      \}\par
      finally\{\par
         System.out.println("finally block");\par
      \}\par
      System.out.println("Out of try-catch-finally block");\par
   \}\par
\}\par
Output:\par
\par
First statement of try block\par
ArithmeticException\par
finally block\par
Out of try-catch-finally block\par
Target keywords: exception thrown in finally block, try catch in finally block, try/catch finally java\par
\par
Flow control in try-catch-finally blocks\par
EXCEPTION HANDLING\par
In this tutorial we will see how to use try-catch-finally blocks for exception handling. Lets see  the try-catch alone first and then we will discuss try-catch-finally.\par
\par
Flow of control in try/catch blocks:\par
\par
when exception doesn\f1\rquote\f0 t occur:\par
When the code which is present in try block\f1\rquote\f0 s body doesn\f1\rquote\f0 t throw any exception then first, the body of try block executes and then the code after catch blocks. In this case catch block never runs as they are meant to be run when an exception occurs. For example-\par
\par
.....\par
int x = 10;\par
int y = 10;\par
try\{\par
   int num= x/y;\par
   System.out.println("next-statement: Inside try block");\par
\}catch(Exception ex)\par
 \{\par
    System.out.println("Exception");\par
 \}\par
System.out.println("next-statement: Outside of try-catch");\par
...\par
Output:\par
\par
next-statement: Inside try block\par
next-statement: Outside of try-catch\par
In the above example exception didn\f1\rquote\f0 t occur in try block so catch block didn\f1\rquote\f0 t run.\par
\par
when exception occurs:\par
First have a look at the below example and then we will discuss it \f1\endash\par
\par
\f0 int x = 0;\par
int y = 10;\par
try\{\par
   int num= y/x;\par
   System.out.println("next-statement: Inside try block");\par
\}catch(Exception ex)\par
 \{\par
    System.out.println("Exception Occurred");\par
 \}\par
System.out.println("next-statement: Outside of try-catch");\par
...\par
Output:\par
\par
Exception Occurred\par
next-statement: Outside of try-catch\par
Point to note in above example: There are two statements present inside try block. Since exception occurred because of first statement, the second statement didn\f1\rquote\f0 t execute. Hence we can conclude that if an exception occurs then the rest of the try block doesn\f1\rquote\f0 t execute and control passes to catch block.\par
\par
Flow of control in try/catch/finally blocks:\par
\par
If exception occurs in try block\f1\rquote\f0 s body then control immediately transferred(skipping rest of the statements in try block) to the catch block. Once catch block finished execution then finally block and after that rest of the program.\par
If there is no exception occurred in the code which is present in try block then first, the try block gets executed completely and then control gets transferred to finally block (skipping catch blocks).\par
If a return statement is encountered either in try or catch block. In such case also finally runs. Control first goes to finally and then it returned back to return statement.\par
Consider the below example to understand above mentioned points:\par
\par
class TestExceptions \{\par
   static void myMethod(int testnum) throws Exception \{\par
      System.out.println ("start - myMethod");\par
      if (testnum == 12) \par
         throw new Exception();\par
      System.out.println("end - myMethod");\par
      return;\tab\par
   \}\par
   public static void main(String  args[]) \{\par
      int testnum = 12;\par
      try \{\par
         System.out.println("try - first statement");\par
         myMethod(testnum);\par
         System.out.println("try - last statement");\par
      \}\par
      catch ( Exception ex) \{\par
         System.out.println("An Exception");\par
      \}\par
      finally \{\par
         System. out. println( "finally") ;\par
      \}\par
      System.out.println("Out of try/catch/finally - statement");\par
   \}\par
\}\par
Output:\par
\par
try - first statement\par
start - myMethod\par
An Exception\par
finally\par
Out of try/catch/finally - statement\par
\par
\par
\par
Java finally return\par
EXCEPTION HANDLING\par
I have already discussed about finally block in my previous tutorial. This post is to learn finally block behavior when a return statement is encountered inside try, catch or finally block.\par
\par
Consider below example \f1\endash  \f0 What do you think?? Will finally would execute even if there is a return failure statement.\par
\par
try \{\par
    //try block\par
    ...\par
    return success;\par
\}\par
catch (Exception ex) \{\par
    //catch block\par
    .....\par
    return failure;\par
\}\par
finally \{\par
    System.out.println("Inside finally");\par
\}\par
The answer is yes. finally block will execute every time. The only case when it doesn\f1\rquote\f0 t execute is when it encounters System.exit().\par
\par
Finally: Example with return statement\par
\par
class FinallyDemo\par
\{\par
   public static int myMethod()\par
   \{\par
       try \{\par
            //try block\par
            return 0;\par
       \}\par
       finally \{\par
            //finally\par
            System.out.println("Inside Finally block");\par
       \}\par
  \}\par
  public static void main(String args[])\par
  \{\par
       System.out.println(FinallyDemo.myMethod());\par
  \}\par
\}\par
Output:\par
\par
Inside Finally block\par
0\par
Does finally block Overrides the values returned by try-catch block?\par
\par
Yes. Finally clause overrides the value returned by try and catch blocks. Consider below example \f1\endash\f0\par
\par
public static int myTestingFuncn()\{\par
  try\{\par
     ....\par
     return 5;\par
  \} finally \{\par
     ....\par
     return 19;\par
   \}\par
\}\par
The above code would return value 19 since the value returned by try has been overridden by finally.\par
\par
How to throw exception in java with example\par
EXCEPTION HANDLING\par
In java we have already defined exception classes such as ArithmeticException, ArrayIndexOutOfBoundsException, NullPointerException etc. There are certain conditions defined for these exceptions and on the occurrence of those conditions they are implicitly thrown by JVM(java virtual machine).\par
\par
Do you know that a programmer can create a new exception and throw it explicitly? These exceptions are known as user-defined exceptions. In order to throw user defined exceptions, throw keyword is being used. In this tutorial, we will see how to create a new exception and throw it in a program using throw keyword.\par
\par
You can also throw an already defined exception like ArithmeticException, IOException etc.\par
\par
Syntax of throw statement\par
\par
throw AnyThrowableInstance;\par
Example:\par
\par
//A void method\par
public void sample()\par
\{\par
   //Statements\par
   //if (somethingWrong) then\par
   IOException e = new IOException();\par
   throw e;\par
   //More Statements\par
 \}\par
Note:\par
\par
A call to the above mentioned sample method should be always placed in a try block as it is throwing a checked exception \f1\endash  \f0 IOException. This is how it the call to above method should be done:\par
MyClass obj =  new MyClass();\par
try\{\par
      obj.sample();\par
\}catch(IOException ioe)\par
 \{\par
      //Your error Message here\par
      System.out.println(ioe);\par
  \}\par
Exceptions in java are compulsorily of type Throwable. If you attempt to throw an object that is not throwable, the  compiler refuses to compile your program and it would show a compilation error.\par
Flow of execution while throwing an exception using throw keyword\par
\par
Whenever a throw statement is encountered in a program the next statement doesn\f1\rquote\f0 t execute. Control immediately transferred to catch block to see if the thrown exception is handled there. If the exception is not handled there then next catch block is being checked for exception and so on. If none of the catch block is handling the thrown exception then a system generated exception message is being populated on screen, same what we get for un-handled exceptions.\par
E.g.\par
\par
class ThrowDemo\{\par
   public static void main(String args[])\{\par
      try\{\par
\tab    char array[] = \{'a','b','g','j'\};\par
\tab    /*I'm displaying the value which does not\par
\tab     * exist so this should throw an exception\par
\tab     */\par
\tab    System.out.println(array[78]);\par
      \}catch(ArithmeticException e)\{\par
\tab     System.out.println("Arithmetic Exception!!");\par
       \}\par
   \}\par
\}\par
Output:\par
\par
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: \par
78 at beginnersbook.com.ThrowDemo.main(Details.java:9)\par
Since the exception thrown was not handled in the catch blocks the system generated exception message got displayed for that particular exception.\par
\par
Few examples of throw exception in Java\par
\par
Example 1: How to throw your own exception explicitly using throw keyword\par
\par
package beginnersbook.com;\par
class MyOwnException extends Exception \{\par
   public MyOwnException(String msg)\{\par
      super(msg);\par
   \}\par
\}\par
\par
class EmployeeTest \{\par
   static void  employeeAge(int age) throws MyOwnException\{\par
      if(age < 0)\par
         throw new MyOwnException("Age can't be less than zero");\par
      else\par
         System.out.println("Input is valid!!");\par
   \}\par
   public static void main(String[] args) \{\par
       try \{\par
            employeeAge(-2);\par
       \}\par
       catch (MyOwnException e) \{\par
            e.printStackTrace();\par
       \}\par
   \}\par
\}\par
Output:\par
\par
beginnersbook.com.MyOwnException: Age can't be less than zero\par
Points to Note: Method call should be in try block as it is throwing an exception.\par
\par
Example2: How to throw an already defined exception using throw keyword\par
\par
package beginnersbook.com;\par
class Exception2\{\par
   static int sum(int num1, int num2)\{\par
      if (num1 == 0)\par
         throw new ArithmeticException("First parameter is not valid");\par
      else\par
         System.out.println("Both parameters are correct!!");\par
      return num1+num2;\par
   \}\par
   public static void main(String args[])\{\par
      int res=sum(0,12);\par
      System.out.println(res);\par
      System.out.println("Continue Next statements");\par
   \}\par
\}\par
Output:\par
\par
Exception in thread main java.lang.ArithmeticException: First parameter is not valid\par
Similarly other exceptions, such as NullPointerException, ArrayIndexOutOfBoundsException etc. can be thrown. That\f1\rquote\f0 s all for the topic how to throw exception in java. Let me know your feedback on this.\par
Throw Keyword Example in Java\par
EXCEPTION HANDLING\par
By default, when an exception condition occurs the system automatically throw an exception to inform user that there is something wrong. However we can also throw exception explicitly based on our own defined condition. Using \f1\ldblquote\f0 throw keyword\f1\rdblquote  \f0 we can throw checked, unchecked and user -defined exceptions. Let\f1\rquote\f0 s have a look at the below example to understand it better.\par
\par
Example of throw keyword\par
\par
package beginnersbook.com;\par
/* In this program we are checking the Student age\par
 * if the student age<12 and weight <40 then our program \par
 * should return that the student is not eligible for registration.\par
 */\par
public class ThrowExample \{\par
   static void checkEligibilty(int stuage, int stuweight)\{ \par
      if(stuage<12 && stuweight<40) \{\par
         throw new ArithmeticException("Student is not eligible for registration"); \par
      \}\par
      else \{\par
         System.out.println("Entries Valid!!"); \par
      \}\par
   \} \par
\par
   public static void main(String args[])\{ \par
     System.out.println("Welcome to the Registration process!!");\par
     checkEligibilty(10, 39); \par
     System.out.println("Have a nice day.."); \par
 \} \par
\}\par
Output:\par
\par
Welcome to the Registration process!!Exception in thread "main" \par
java.lang.ArithmeticException: Student is not eligible for registration\par
 at beginnersbook.com.ThrowExample.checkEligibilty(ThrowExample.java:9)\par
 at beginnersbook.com.ThrowExample.main(ThrowExample.java:18)\par
As you can see in the above example that we threw an unchecked exception (Runtime exception) based on our own custom defined conditions using \f1\ldblquote\f0 throw keyword\f1\rdblquote\f0 . Similarly we can throw checked and custom exception as well.\par
Throws Keyword Example in Java\par
EXCEPTION HANDLING\par
As we know that there are two types of exception \f1\endash  \f0 checked and unchecked. Checked exceptions (compile time) are the one which forces the programmer to handle it, without which the program doesn\f1\rquote\f0 t compile successfully. While unchecked exception (Runtime) doesn\f1\rquote\f0 t get checked during compilation. \f1\ldblquote\f0 Throws keyword\f1\rdblquote  \f0 is mainly used for handling checked exception as using throws we can declare multiple exceptions in one go. Let\f1\rquote\f0 s understand this with the help of an example.\par
\par
Example of throws Keyword\par
\par
In this example the method \f1\ldblquote\f0 mymethod\f1\rdblquote  \f0 is throwing two checked exceptions so we have declared those exceptions in the method signature using throws Keyword. If we do not declare these exceptions then the program will throw a compilation error.\par
\par
package beginnersbook.com;\par
import java.io.*;\par
public class ThrowExample \{ \par
  void mymethod(int num)throws IOException, ClassNotFoundException\{ \par
     if(num==1)\par
        throw new IOException("Exception Message1");\par
     else\par
        throw new ClassNotFoundException("Exception Message2");\par
  \} \par
\} \par
\par
class Demo\{ \par
  public static void main(String args[])\{ \par
   try\{ \par
     ThrowExample obj=new ThrowExample(); \par
     obj.mymethod(1); \par
   \}catch(Exception ex)\{\par
     System.out.println(ex);\par
    \} \par
  \}\par
\}\par
Output:\par
\par
java.io.IOException: Exception Message1\par
Since we passed the argument as 1 during the function call, the program thrown IOException.\par
\par
Throws clause in java \f1\endash  \f0 Exception handling\par
EXCEPTION HANDLING\par
Use of throws keyword in Java\par
\par
1. The throws keyword is used in method declaration, in order to explicitly specify the exceptions that a particular method might throw. When a method declaration has one or more exceptions defined using throws clause then the method-call must handle all the defined exceptions.\par
2. When defining a method you must include a throws clause to declare those exceptions that might be thrown but doesn\f1\rquote\f0 t get caught in the method.\par
3. If a method is using throws clause along with few exceptions then this implicitly tells other methods that \f1\endash  \ldblquote  \f0 If you call me, you must handle these exceptions that I throw\f1\rdblquote\f0 .\par
\par
Syntax of Throws in java:\par
\par
void MethodName() throws ExceptionName\{\par
    Statement1\par
    ...\par
    ...\par
\}\par
E.g:\par
\par
public void sample() throws IOException\{\par
     //Statements\par
     //if (somethingWrong)\par
     IOException e = new IOException();\par
     throw e;\par
     //More Statements\par
\}\par
Note: In case a method throws more than one exception, all of them should be listed in throws clause. PFB the example to understand the same.\par
\par
public void sample() throws IOException, SQLException\par
\{\par
    //Statements\par
\}\par
The above method has both IOException and SQLException listed in throws clause. There can be any number of exceptions defined using throws clause.\par
\par
Complete Example of Java throws Clause\par
class Demo\par
\{\par
   static void throwMethod() throws NullPointerException\par
   \{\par
       System.out.println ("Inside throwMethod");\par
       throw new NullPointerException ("Demo"); \par
   \} \par
   public static void main(String args[])\par
   \{\par
       try\par
       \{\par
          throwMethod();\par
       \}\par
       catch (NullPointerException exp)\par
       \{\par
          System.out.println ("The exception get caught" +exp);\par
       \}\par
    \}\par
\}\par
The output of the above program is:\par
\par
Inside throwMethod\par
The exception get caught java.lang.IllegalAccessException: Demo\par
\par
Difference between throw and throws in java\par
EXCEPTION HANDLING\par
In my previous tutorials I\f1\rquote\f0 ve covered below topics. In this post we are going to discuss difference between throw and throws in Java. Below are the links of my tutorials on throw and throws. I would highly recommend you to go through the below tutorials so that it would be easy for you to understand these terms.\par
\par
Throw in Java\par
Throws in Java\par
throw keyword example\par
throws keyword example\par
Throw vs Throws in java\par
\par
1. Throws clause in used to declare an exception and thow keyword is used to throw an exception explicitly.\par
\par
2. If we see syntax wise than throw is followed by an instance variable and throws is followed by exception class names.\par
\par
3. The keyword throw is used inside method body to invoke an exception and throws clause is used in method declaration (signature).\par
\par
for e.g.\par
\par
Throw:\par
\par
....\par
static\{\par
try \{\par
throw new Exception("Something went wrong!!");\par
\} catch (Exception exp) \{\par
System.out.println("Error: "+exp.getMessage());\par
\}\par
\}\par
....\par
Throws:\par
\par
public void sample() throws ArithmeticException\{\par
 //Statements\par
\par
.....\par
\par
 //if (Condition : There is an error)\par
ArithmeticException exp = new ArithmeticException();\par
 throw exp;\par
...\par
\}\par
4. By using Throw keyword in java you cannot throw more than one exception but using throws you can declare multiple exceptions. PFB the examples.\par
\par
for e.g.\par
\par
Throw:\par
\par
throw new ArithmeticException("An integer should not be divided by zero!!")\par
throw new IOException("Connection failed!!")\par
Throws:\par
\par
throws IOException, ArithmeticException, NullPointerException, \par
ArrayIndexOutOfBoundsException\par
That\f1\rquote\f0 s all I have for this topic. Let me know if I missed any difference between throw and throws in Java. If you have any queries regarding it, please feel free to ask me. Just drop a comment below, I\f1\rquote\f0 ll try to answer as soon as possible.\par
\par
Java Exception Handling examples\par
EXCEPTION HANDLING\par
Here we have shared examples of few most frequently seen exceptions in java. These examples will help you understand Exception handling in Java.\par
\par
Example 1: Arithmetic exception\par
\par
Class: Java.lang.ArithmeticException\par
This is a built-in-class present in java.lang package. This exception occurs when an integer is divided by zero.\par
\par
class ExceptionDemo1\par
\{\par
   public static void main(String args[])\par
   \{\par
      try\{\par
         int num1=30, num2=0;\par
         int output=num1/num2;\par
         System.out.println ("Result = " +output);\par
      \}\par
      catch(ArithmeticException e)\{\par
         System.out.println ("Arithmetic Exception: You can't divide an integer by 0");\par
      \}\par
   \}\par
\}\par
Output of above program:\par
\par
Arithmetic Exception: You can't divide an integer by 0\par
Explanation: In the above example I\f1\rquote\f0 ve divided an integer by a zero and due to which ArithmeticException is thrown.\par
\par
Example 2: ArrayIndexOutOfBounds Exception\par
\par
Class: Java.lang.ArrayIndexOutOfBoundsException\par
\par
This is a built in class present in java.lang package. This exception occurs when the referenced element does not exist in the array. For e.g. If array is having only 5 elements and we are trying to display 7th element then it would throw this exception.\par
\par
Example:\par
\par
class ExceptionDemo2\par
\{\par
   public static void main(String args[])\par
   \{\par
      try\{\par
        int a[]=new int[10];\par
        //Array has only 10 elements\par
        a[11] = 9;\par
      \}\par
      catch(ArrayIndexOutOfBoundsException e)\{\par
         System.out.println ("ArrayIndexOutOfBounds");\par
      \}\par
   \}\par
\}\par
Output:\par
\par
ArrayIndexOutOfBounds\par
In the above example the array is initialized to store only 10 elements indexes 0 to 9. Since we are invoking index 11 that\f1\rquote\f0 s why it is throwing this exception.\par
\par
Example 3: NumberFormat Exception\par
\par
Class: Java.lang.NumberFormatException\par
\par
The object of the above built-in class gets created whenever a string is parsed to any numeric variable.\par
For E.g. The statement int num=Integer.parseInt ("XYZ") ; would throw NumberFormatException because String \f1\ldblquote\f0 XYZ\f1\rdblquote  \f0 cannot be parsed to int.\par
\par
Complete Code:\par
\par
class ExceptionDemo3\par
\{\par
   public static void main(String args[])\par
   \{\par
      try\{\par
\tab  int num=Integer.parseInt ("XYZ") ;\par
\tab  System.out.println(num);\par
      \}catch(NumberFormatException e)\{\par
\tab   System.out.println("Number format exception occurred");\par
       \}\par
   \}\par
\}\par
Output:\par
\par
Number format exception occurred\par
Example 4: StringIndexOutOfBound Exception\par
\par
Class: Java.lang.StringIndexOutOfBoundsException\par
\par
An object of this class gets created whenever an index is invoked of a string, which is not in the range.\par
Each character of a string object is stored in a particular index starting from 0.\par
To get a character present in a particular index of a string we can use a method charAt(int) of java.lang.String where int argument is the index.\par
E.g.\par
\par
class ExceptionDemo4\par
\{\par
   public static void main(String args[])\par
   \{\par
      try\{\par
\tab  String str="easysteps2buildwebsite";\par
\tab  System.out.println(str.length());;\par
\tab  char c = str.charAt(0);\par
\tab  c = str.charAt(40);\par
\tab  System.out.println(c);\par
      \}catch(StringIndexOutOfBoundsException e)\{\par
\tab   System.out.println("StringIndexOutOfBoundsException!!");\par
       \}\par
   \}\par
\}\par
Output:\par
\par
22\par
StringIndexOutOfBoundsException!!\par
Exception occurred because the referenced index was not present in the String.\par
\par
Example 5: NullPointer Exception\par
\par
Class: Java.lang.NullPointer Exception\par
An object of this class gets created whenever a member is invoked with a \f1\ldblquote\f0 null\f1\rdblquote  \f0 object.\par
Example:\par
\par
package beginnersbook.com;\par
class Exception2\par
\{\par
public static void main(String args[])\par
\{\par
\tab try\{\par
\tab\tab String str=null;\par
\tab\tab System.out.println (str.length());\par
\tab\}catch(NullPointerException e)\{\par
\tab\tab System.out.println("NullPointerException..");\par
\tab\}\par
\}\par
\}\par
Output:\par
\par
NullPointerException..\par
Here, length() is the function, which should be used on an object. However in the above example String object str is null so it is not an object due to which NullPointerException occurred.\lang9\par
\par
\par
\par
Java Serialization\par
 JAVA TUTORIALS\par
Here we are gonna discuss how to serialize and de-serialize an object and what is the use of it.\par
\par
What is Java Serialization?\par
\par
Serialization is a mechanism to convert an object into stream of bytes so that it can be written into a file, transported through a network or stored into database. De-serialization is just a vice versa. In simple words serialization is converting an object to stream of bytes and de-serialization is rebuilding the object from stream of bytes. Java Serialiation API provides the features to perform seralization & de-serialization. A class must implement java.io.Serializable interface to be eligible for serialization.\par
\par
Lets take an example to understand the concepts better:\par
\par
Example\par
This class implements Serializable interface which means it can be serialized. All the fields of this class can be written to a file after being converted to stream of bytes, except those fields that are declared transient. In the below example we have two transient fields, these fields will not take part in serialization.\par
Student.java\par
\par
public class Student implements java.io.Serializable\{\par
  private int stuRollNum;\par
  private int stuAge;\par
  private String stuName;\par
  private transient String stuAddress;\par
  private transient int stuHeight;\par
 \par
  public Student(int roll, int age, String name,\par
  String address, int height) \{\par
    this.stuRollNum = roll;\par
    this.stuAge = age;\par
    this.stuName = name;\par
    this.stuAddress = address;\par
    this.stuHeight = height;\par
  \}\par
 \par
  public int getStuRollNum() \{\par
    return stuRollNum;\par
  \}\par
  public void setStuRollNum(int stuRollNum) \{\par
    this.stuRollNum = stuRollNum;\par
  \}\par
  public int getStuAge() \{\par
    return stuAge;\par
  \}\par
  public void setStuAge(int stuAge) \{\par
    this.stuAge = stuAge;\par
  \}\par
  public String getStuName() \{\par
    return stuName;\par
  \}\par
  public void setStuName(String stuName) \{\par
    this.stuName = stuName;\par
  \}\par
  public String getStuAddress() \{\par
    return stuAddress;\par
  \}\par
  public void setStuAddress(String stuAddress) \{\par
    this.stuAddress = stuAddress;\par
  \}\par
  public int getStuHeight() \{\par
    return stuHeight;\par
  \}\par
  public void setStuHeight(int stuHeight) \{\par
    this.stuHeight = stuHeight;\par
  \}\par
\}\par
Serialization of Object\par
\par
This class is writing an object of Student class to the Student.ser file. We are using FileOutputStream and ObjectOutputStream to write the object to File.\par
\par
Note: As per the best practices of Java Serialization, the file name should have .ser extension.\par
\par
import java.io.FileOutputStream;\par
import java.io.ObjectOutputStream;\par
import java.io.IOException;\par
public class SendClass\par
\{\par
  public static void main(String args[])\par
  \{\par
    Student obj = new Student(101, 25, "Chaitanya", "Agra", 6);\par
    try\{ \par
      FileOutputStream fos = new FileOutputStream("Student.ser"); \par
      ObjectOutputStream oos = new ObjectOutputStream(fos);\par
      oos.writeObject(obj);\par
      oos.close();\par
      fos.close();\par
      System.out.println("Serialzation Done!!");\par
   \}catch(IOException ioe)\{\par
      System.out.println(ioe);\par
    \}\par
  \}\par
\}\par
Output:\par
\par
Serialzation Done!!\par
De-serialization of Object\par
\par
This class would rebuilt the object of Student class after reading the stream of bytes from the file. Observe the output of this class, student address and student height fields are having null & 0 values consecutively. This is because these fields were declared transient in the Student class.\par
\par
import java.io.FileInputStream;\par
import java.io.ObjectInputStream;\par
import java.io.IOException;\par
public class AcceptClass \{\par
\par
 public static void main(String args[])\par
 \{\par
    Student o=null;\par
    try\{\par
      FileInputStream fis = new FileInputStream("Student.ser");\par
      ObjectInputStream ois = new ObjectInputStream(fis);\par
      o = (Student)ois.readObject();\par
      ois.close();\par
      fis.close();\par
    \}\par
    catch(IOException ioe)\par
    \{\par
       ioe.printStackTrace();\par
       return;\par
    \}catch(ClassNotFoundException cnfe)\par
     \{\par
       System.out.println("Student Class is not found.");\par
       cnfe.printStackTrace();\par
       return;\par
     \}\par
    System.out.println("Student Name:"+o.getStuName());\par
    System.out.println("Student Age:"+o.getStuAge());\par
    System.out.println("Student Roll No:"+o.getStuRollNum());\par
    System.out.println("Student Address:"+o.getStuAddress());\par
    System.out.println("Student Height:"+o.getStuHeight());\par
 \}\par
\}\par
Output:\par
\par
Student Name:Chaitanya\par
Student Age:25\par
Student Roll No:101\par
Student Address:null\par
Student Height:0\par
\par
How to serialize HashMap in java\par
 JAVA COLLECTIONS\par
HashMap class is serialized by default which means we need not to implement Serializable interface in order to make it eligible for Serialization. In this tutorial we will learn How to write HashMap object and it\f1\rquote\f0 s content into a file and How to read the HashMap object from the file. Before I share the complete code for this let me give a brief info about Serialization and De-serialization.\par
\par
Serialization: It is a process of writing an Object into file along with its attributes and content. It internally converts the object in stream of bytes.\par
\par
De-Serialization: It is a process of reading the Object and it\f1\rquote\f0 s properties from a file along with the Object\f1\rquote\f0 s content.\par
\par
Example:\par
Serialization of HashMap: In the below class we are storing the HashMap content in a hashmap.ser serialized file. Once you run the below code it would produce a hashmap.ser file. This file would be used in the next class for de-serialization.\par
\par
package beginnersbook.com;\par
import java.io.*;\par
import java.util.HashMap;\par
public class Details\par
\{\par
      public static void main(String [] args)\par
      \{\par
           HashMap<Integer, String> hmap = new HashMap<Integer, String>();\par
           //Adding elements to HashMap\par
           hmap.put(11, "AB");\par
           hmap.put(2, "CD");\par
           hmap.put(33, "EF");\par
           hmap.put(9, "GH");\par
           hmap.put(3, "IJ");\par
           try\par
           \{\par
                  FileOutputStream fos =\par
                     new FileOutputStream("hashmap.ser");\par
                  ObjectOutputStream oos = new ObjectOutputStream(fos);\par
                  oos.writeObject(hmap);\par
                  oos.close();\par
                  fos.close();\par
                  System.out.printf("Serialized HashMap data is saved in hashmap.ser");\par
           \}catch(IOException ioe)\par
            \{\par
                  ioe.printStackTrace();\par
            \}\par
      \}\par
\}\par
Output:\par
\par
Serialized HashMap data is saved in hashmap.ser\par
De-Serialization: Here we are reproducing the HashMap object and it\f1\rquote\f0 s content from a serialized file which we have created by running the above code.\par
\par
package beginnersbook.com;\par
import java.io.*;\par
import java.util.HashMap;\par
import java.util.Map;\par
import java.util.Iterator;\par
import java.util.Set;\par
public class Student\par
\{\par
   public static void main(String [] args)\par
   \{\par
      HashMap<Integer, String> map = null;\par
      try\par
      \{\par
         FileInputStream fis = new FileInputStream("hashmap.ser");\par
         ObjectInputStream ois = new ObjectInputStream(fis);\par
         map = (HashMap) ois.readObject();\par
         ois.close();\par
         fis.close();\par
      \}catch(IOException ioe)\par
      \{\par
         ioe.printStackTrace();\par
         return;\par
      \}catch(ClassNotFoundException c)\par
      \{\par
         System.out.println("Class not found");\par
         c.printStackTrace();\par
         return;\par
      \}\par
      System.out.println("Deserialized HashMap..");\par
      // Display content using Iterator\par
      Set set = map.entrySet();\par
      Iterator iterator = set.iterator();\par
      while(iterator.hasNext()) \{\par
         Map.Entry mentry = (Map.Entry)iterator.next();\par
         System.out.print("key: "+ mentry.getKey() + " & Value: ");\par
         System.out.println(mentry.getValue());\par
      \}\par
    \}\par
\}\par
Output:\par
\par
Deserialized HashMap..\par
key: 9 & Value: GH\par
key: 2 & Value: CD\par
key: 11 & Value: AB\par
key: 33 & Value: EF\par
key: 3 & Value: IJ\par
\par
\par
How to serialize ArrayList in java\par
 JAVA COLLECTIONS\par
ArrayList is serializable by default. This means you need not to implement Serializable interface explicitly in order to serialize an ArrayList. In this tutorial we will learn how to serialize and de-serialize an ArrayList.\par
\par
Example:\par
\par
Serialization: Run the below class and it will create a file myfile which will be having ArrayList object in form of Stream of bytes. We would be using \f1\ldblquote\f0 myfile\f1\rdblquote  \f0 at the receivers end to recreate the Object from stream of bytes. Note: We did not implemented the Serializable interface in the below class because ArrayList is already been serialized by default.\par
\par
package beginnersbook.com;\par
import java.util.ArrayList;\par
import java.io.*;\par
public class ArrayListSerialization\par
\{\par
   public static void main(String [] args)\par
   \{\par
       ArrayList<String> al=new ArrayList<String>();\par
       al.add("Hello");\par
       al.add("Hi");\par
       al.add("Howdy");\par
\par
       try\{\par
         FileOutputStream fos= new FileOutputStream("myfile");\par
         ObjectOutputStream oos= new ObjectOutputStream(fos);\par
         oos.writeObject(al);\par
         oos.close();\par
         fos.close();\par
       \}catch(IOException ioe)\{\par
            ioe.printStackTrace();\par
        \}\par
   \}\par
\}\par
De-Serialization:\par
\par
In this class we are retrieving the stream of bytes from myfile which we have stored using the above class. We are type casting the returned object to ArrayList and displaying the elements of ArrayList. Observe the output: We are getting the same elements which we have added to the ArrayList before the serialization.\par
\par
package beginnersbook.com;\par
import java.io.*;\par
import java.util.ArrayList;\par
public class DeSerializationClass \par
\{\par
    public static void main(String [] args)\par
    \{\par
        ArrayList<String> arraylist= new ArrayList<String>();\par
        try\par
        \{\par
            FileInputStream fis = new FileInputStream("myfile");\par
            ObjectInputStream ois = new ObjectInputStream(fis);\par
            arraylist = (ArrayList) ois.readObject();\par
            ois.close();\par
            fis.close();\par
         \}catch(IOException ioe)\{\par
             ioe.printStackTrace();\par
             return;\par
          \}catch(ClassNotFoundException c)\{\par
             System.out.println("Class not found");\par
             c.printStackTrace();\par
             return;\par
          \}\par
        for(String tmp: arraylist)\{\par
            System.out.println(tmp);\par
        \}\par
   \}\par
\}\par
Output:\par
\par
Hello\par
Hi\par
Howdy\par
That\f1\rquote\f0 s all I have for the topic serialization of ArrayList. Please let me know if you have any questions.\par
\par
\par
\par
\par
\par
Java \f1\endash  \f0 String Class and its methods\par
STRING HANDLING\par
String is nothing but a sequence of characters, for e.g. \f1\ldblquote\f0 Hello\f1\rdblquote  \f0 is a string of 5 characters. In java, string is an immutable object which means it is constant and can cannot be changed once it has been created. In this tutorial we will learn about String class and String methods in detail along with many other Java String tutorials.\par
\par
Creating a String\par
\par
There are two ways to create a String in Java\par
\par
String literal\par
Using new keyword\par
String literal\par
\par
In java, Strings can be created like this: Assigning a String literal to a String instance:\par
\par
String str1 = "Welcome";\par
String str2 = "Welcome";\par
The problem with this approach: As I stated in the beginning that String is an object in Java. However we have not created any string object using new keyword above. The compiler does that task for us it creates a string object having the string literal (that we have provided , in this case it is \f1\ldblquote\f0 Welcome\f1\rdblquote\f0 ) and assigns it to the provided string instances.\par
\par
But if the object already exist in the memory it does not create a new Object rather it assigns the same old object to the new instance, that means even though we have two string instances above(str1 and str2) compiler only created on string object (having the value \f1\ldblquote\f0 Welcome\f1\rdblquote\f0 ) and assigned the same to both the instances. For example there are 10 string instances that have same value, it means that in memory there is only one object having the value and all the 10 string instances would be pointing to the same object.\par
\par
What if we want to have two different object with the same string? For that we would need to create strings using new keyword.\par
\par
Using New Keyword\par
\par
As we saw above that when we tried to assign the same string object to two different literals, compiler only created one object and made both of the literals to point the same object. To overcome that approach we can create strings like this:\par
\par
String str1 = new String("Welcome");\par
String str2 = new String("Welcome");\par
In this case compiler would create two different object in memory having the same text.\par
\par
Java \f1\endash  \f0 String charAt() Method example\par
STRING HANDLING\par
The method charAt(int index) returns the character at the specified index. The index value should lie between 0 and length()-1. For e.g. s.charAt(0) would return the first character of the string \f1\ldblquote\f0 s\f1\rdblquote\f0 . It throws IndexOutOfBoundsException if the index is less than zero or greater than equal to the length of the string (index<0|| index>=length()).\par
\par
Example:\par
\par
In this example we are fetching few characters of the input string using charAt() method.\par
\par
public class CharAtExample \{\par
    public static void main(String args[]) \{\par
        String str = "Welcome to string handling tutorial";\par
\tab char ch1 = str.charAt(0);\par
\tab char ch2 = str.charAt(5);\par
\tab char ch3 = str.charAt(11);\par
\tab char ch4 = str.charAt(20);\par
\tab System.out.println("Character at 0 index is: "+ch1);\par
\tab System.out.println("Character at 5th index is: "+ch2);\par
\tab System.out.println("Character at 11th index is: "+ch3);\par
\tab System.out.println("Character at 20th index is: "+ch4);\par
    \}\par
\}\par
Output:\par
\par
Character at 0 index is: W\par
Character at 5th index is: m\par
Character at 11th index is: s\par
Character at 20th index is: n\par
\par
\par
ava \f1\endash  \f0 String getChars() Method example\par
STRING HANDLING\par
The method getChars() is used for copying String characters to an Array of chars.\par
\par
public void getChars(int srcBegin, int srcEnd, char[] dest, int destBegin)\par
Parameters description:\par
srcBegin \f1\endash  \f0 index of the first character in the string to copy.\par
srcEnd \f1\endash  \f0 index after the last character in the string to copy.\par
dest \f1\endash  \f0 Destination array of characters in which the characters from String gets copied.\par
destBegin \f1\endash  \f0 The index in Array starting from where the chars will be pushed into the Array.\par
\par
It throws IndexOutOfBoundsException \f1\endash  \f0 If any of the following conditions occurs:\par
(srcBegin<0) srcBegin is less than zero. (srcBegin>srcEnd) srcBegin is greater than srcEnd.\par
(srcEnd > length of string) srcEnd is greater than the length of this string.\par
(destBegin<0) destBegin is negative.\par
dstBegin+(srcEnd-srcBegin) is larger than dest.length.\par
\par
Example: getChars() method\par
\par
public class GetCharsExample\{\par
   public static void main(String args[])\{\par
       String str = new String("This is a String Handling Tutorial");\par
       char[] array = new char[6];\par
       str.getChars(10, 16, array, 0);\par
       System.out.println("Array Content:" );\par
       for(char temp: array)\{\par
           System.out.print(temp);\par
       \}\par
\par
       char[] array2 = new char[]\{'a','a','a','a','a','a','a','a'\};\par
       str.getChars(10, 16, array2, 2);\par
       System.out.println("Second Array Content:" );\par
       for(char temp: array2)\{\par
    \tab    System.out.print(temp);\par
       \}\par
   \}\tab\par
\}\par
Output:\par
\par
Array Content:\par
StringSecond Array Content:\par
aaString\par
\par
Java \f1\endash  \f0 String equals() and equalsIgnoreCase() Methods example\par
STRING HANDLING\par
In this tutorial we will discuss equals() and equalsIgnoreCase() methods. Both of these methods are used for comparing two strings. The only difference between them is that the equals() methods considers the case while equalsIgnoreCase() methods ignores the case during comparison. For e.g. The equals() method would return false if we compare the strings \f1\ldblquote\f0 TEXT\f1\rdblquote  \f0 and \f1\ldblquote\f0 text\f1\rdblquote  \f0 however equalsIgnoreCase() would return true.\par
\par
boolean equals(String str): Case sensitive comparison\par
boolean equalsIgnoreCase(String str): Case in-sensitive comparison\par
\par
Example 1: equals()\par
\par
public class EqualsExample1\{\par
   public static void main(String args[])\{\par
       String str1= new String("Hello");\par
       String str2= new String("Hi");\par
       String str3= new String("Hello");\par
       System.out.println("str1 equals to str2:"+str1.equals(str2));\par
       System.out.println("str1 equals to str3:"+str1.equals(str3));\par
       System.out.println("str1 equals to Welcome:"+str1.equals("Welcome"));\par
       System.out.println("str1 equals to Hello:"+str1.equals("Hello"));\par
       System.out.println("str1 equals to hello:"+str1.equals("hello"));\par
   \}\par
\}\par
Output:\par
\par
str1 equals to str2:false\par
str1 equals to str3:true\par
str1 equals to Welcome:false\par
str1 equals to Hello:true\par
str1 equals to hello:false\par
Example2: equalsIgnoreCase()\par
\par
public class EqualsExample2\{\par
   public static void main(String args[])\{\par
       String str1= new String("Apple");\par
       String str2= new String("MANGO");\par
       String str3= new String("APPLE");\par
       System.out.println("str1 equals to str2:"+str1.equalsIgnoreCase(str2));\par
       System.out.println("str1 equals to str3:"+str1.equalsIgnoreCase(str3));\par
       System.out.println("str1 equals to Welcome:"+str1.equalsIgnoreCase("Welcome"));\par
       System.out.println("str1 equals to Apple:"+str1.equalsIgnoreCase("Apple"));\par
       System.out.println("str2 equals to mango:"+str2.equalsIgnoreCase("mango"));\par
   \}\par
\}\par
Output:\par
\par
str1 equals to str2:false\par
str1 equals to str3:true\par
str1 equals to Welcome:false\par
str1 equals to Apple:true\par
str2 equals to mango:true\par
\par
Java \f1\endash  \f0 String contentEquals() Method example\par
STRING HANDLING\par
The method contentEquals() compares the String with the String Buffer and returns a boolean value. It returns true if the String matches to the String buffer else it returns false.\par
\par
boolean contentEquals(StringBuffer sb)\par
\par
Example\par
\par
In this example we have two Strings and two String Buffers. We are comparing the Strings with String Buffers using the contentEquals() method. Here we are displaying the result by directly calling the method in System.out.println statement. However you can also store the returned value in a boolean variable and use it further like this: boolean var = str1.contentEquals(sb1);\par
\par
public class ContentEqualsExample \{\par
   public static void main(String args[]) \{\par
       String str1 = "First String";\par
       String str2 = "Second String";\par
       StringBuffer str3 = new StringBuffer( "Second String");\par
       StringBuffer str4 = new StringBuffer( "First String");\par
       System.out.println("str1 equals to str3:"+str1.contentEquals(str3));\par
       System.out.println("str2 equals to str3:"+str2.contentEquals(str3));\par
       System.out.println("str1 equals to str4:"+str1.contentEquals(str4));\par
       System.out.println("str2 equals to str4:"+str2.contentEquals(str4));\par
   \}\par
\}\par
Output:\par
\par
str1 equals to str3:false\par
str2 equals to str3:true\par
str1 equals to str4:true\par
str2 equals to str4:false\par
\par
Java \f1\endash  \f0 String equals() and equalsIgnoreCase() Methods example\par
STRING HANDLING\par
In this tutorial we will discuss equals() and equalsIgnoreCase() methods. Both of these methods are used for comparing two strings. The only difference between them is that the equals() methods considers the case while equalsIgnoreCase() methods ignores the case during comparison. For e.g. The equals() method would return false if we compare the strings \f1\ldblquote\f0 TEXT\f1\rdblquote  \f0 and \f1\ldblquote\f0 text\f1\rdblquote  \f0 however equalsIgnoreCase() would return true.\par
\par
boolean equals(String str): Case sensitive comparison\par
boolean equalsIgnoreCase(String str): Case in-sensitive comparison\par
\par
Example 1: equals()\par
\par
public class EqualsExample1\{\par
   public static void main(String args[])\{\par
       String str1= new String("Hello");\par
       String str2= new String("Hi");\par
       String str3= new String("Hello");\par
       System.out.println("str1 equals to str2:"+str1.equals(str2));\par
       System.out.println("str1 equals to str3:"+str1.equals(str3));\par
       System.out.println("str1 equals to Welcome:"+str1.equals("Welcome"));\par
       System.out.println("str1 equals to Hello:"+str1.equals("Hello"));\par
       System.out.println("str1 equals to hello:"+str1.equals("hello"));\par
   \}\par
\}\par
Output:\par
\par
str1 equals to str2:false\par
str1 equals to str3:true\par
str1 equals to Welcome:false\par
str1 equals to Hello:true\par
str1 equals to hello:false\par
Example2: equalsIgnoreCase()\par
\par
public class EqualsExample2\{\par
   public static void main(String args[])\{\par
       String str1= new String("Apple");\par
       String str2= new String("MANGO");\par
       String str3= new String("APPLE");\par
       System.out.println("str1 equals to str2:"+str1.equalsIgnoreCase(str2));\par
       System.out.println("str1 equals to str3:"+str1.equalsIgnoreCase(str3));\par
       System.out.println("str1 equals to Welcome:"+str1.equalsIgnoreCase("Welcome"));\par
       System.out.println("str1 equals to Apple:"+str1.equalsIgnoreCase("Apple"));\par
       System.out.println("str2 equals to mango:"+str2.equalsIgnoreCase("mango"));\par
   \}\par
\}\par
Output:\par
\par
str1 equals to str2:false\par
str1 equals to str3:true\par
str1 equals to Welcome:false\par
str1 equals to Apple:true\par
str2 equals to mango:true\par
\par
Java \f1\endash  \f0 String compareTo() Method example\par
STRING HANDLING\par
The method compareTo() is used for comparing two strings lexicographically. Each character of both the strings is converted into a Unicode value for comparison. If both the strings are equal then this method returns 0 else it returns positive or negative value. The result is positive if the first string is lexicographically greater than the second string else the result would be negative.\par
\par
This method can be used as follows:\par
\par
int compareTo(String str)\par
Here the comparison is between string literals. For e.g. string1.compareTo(string2) where string1 and string2 are String literals.\par
\par
int compareTo(Object obj)\par
This is a comparison between a string and an object. For e.g. string1.compareTo("Just a String object") where string1 is a literal whose value would be compared with the string specified in the method argument.\par
\par
Example\par
\par
Here we have three Strings and we are comparing them with each other using compareTo() method.\par
\par
public class CompareToExample \{\par
   public static void main(String args[]) \{\par
       String str1 = "String method tutorial";\par
       String str2 = "compareTo method example";\par
       String str3 = "String method tutorial";\par
\par
       int var1 = str1.compareTo( str2 );\par
       System.out.println("str1 & str2 comparison: "+var1);\par
\par
       int var2 = str1.compareTo( str3 );\par
       System.out.println("str1 & str3 comparison: "+var2);\par
\par
       int var3 = str2.compareTo("compareTo method example");\par
       System.out.println("str2 & string argument comparison: "+var3);\par
   \}\par
\}\par
Output:\par
\par
str1 & str2 comparison: -16\par
str1 & str3 comparison: 0\par
str2 & string argument comparison: 0\par
\par
Java \f1\endash  \f0 String compareToIgnoreCase() Method example\par
STRING HANDLING\par
The method compareToIgnoreCase() is similar to the compareTo() method as it also compares two strings lexicographically. The only difference between them is that compareToIgnoreCase() ignores the case (uppercase or lowercase) while comparing two strings. Similar to compareTo() this method also compares the strings based on the Unicode value of their each character. It returns 0 when the strings are equal else it returns positive or negative value.\par
\par
int compareToIgnoreCase(String str)\par
Example\par
\par
In the below example we have three String literals which have same value but the case is different. string1 is in uppercase, string2 is in lowercase and string3 is a mix of uppercase and lowercase. We are using compareToIgnoreCase() method to compare these strings.\par
\par
public class CompareExample \{\par
   public static void main(String args[]) \{\par
       String string1 = "HELLO";\par
       String string2 = "hello";\par
       String string3 = "Hello";\par
\par
       int var1 = string1.compareToIgnoreCase(string2);\par
       System.out.println("string1 and string2 comparison: "+var1);\par
\par
       int var2 = string1.compareToIgnoreCase(string3);\par
       System.out.println("string1 and string3 comparison: "+var2);\par
\par
       int var3 = string1.compareToIgnoreCase("HeLLo");\par
       System.out.println("string1 and HeLLo comparison: "+var3);\par
   \}\par
\}\par
Output:\par
\par
string1 and string2 comparison: 0\par
string1 and string3 comparison: 0\par
string1 and HeLLo comparison: 0\par
\par
Java \f1\endash  \f0 String contentEquals() Method example\par
STRING HANDLING\par
The method contentEquals() compares the String with the String Buffer and returns a boolean value. It returns true if the String matches to the String buffer else it returns false.\par
\par
boolean contentEquals(StringBuffer sb)\par
\par
Example\par
\par
In this example we have two Strings and two String Buffers. We are comparing the Strings with String Buffers using the contentEquals() method. Here we are displaying the result by directly calling the method in System.out.println statement. However you can also store the returned value in a boolean variable and use it further like this: boolean var = str1.contentEquals(sb1);\par
\par
public class ContentEqualsExample \{\par
   public static void main(String args[]) \{\par
       String str1 = "First String";\par
       String str2 = "Second String";\par
       StringBuffer str3 = new StringBuffer( "Second String");\par
       StringBuffer str4 = new StringBuffer( "First String");\par
       System.out.println("str1 equals to str3:"+str1.contentEquals(str3));\par
       System.out.println("str2 equals to str3:"+str2.contentEquals(str3));\par
       System.out.println("str1 equals to str4:"+str1.contentEquals(str4));\par
       System.out.println("str2 equals to str4:"+str2.contentEquals(str4));\par
   \}\par
\}\par
Output:\par
\par
str1 equals to str3:false\par
str2 equals to str3:true\par
str1 equals to str4:true\par
str2 equals to str4:false\par
Java \f1\endash  \f0 String compareTo() Method example\par
STRING HANDLING\par
The method compareTo() is used for comparing two strings lexicographically. Each character of both the strings is converted into a Unicode value for comparison. If both the strings are equal then this method returns 0 else it returns positive or negative value. The result is positive if the first string is lexicographically greater than the second string else the result would be negative.\par
\par
This method can be used as follows:\par
\par
int compareTo(String str)\par
Here the comparison is between string literals. For e.g. string1.compareTo(string2) where string1 and string2 are String literals.\par
\par
int compareTo(Object obj)\par
This is a comparison between a string and an object. For e.g. string1.compareTo("Just a String object") where string1 is a literal whose value would be compared with the string specified in the method argument.\par
\par
Example\par
\par
Here we have three Strings and we are comparing them with each other using compareTo() method.\par
\par
public class CompareToExample \{\par
   public static void main(String args[]) \{\par
       String str1 = "String method tutorial";\par
       String str2 = "compareTo method example";\par
       String str3 = "String method tutorial";\par
\par
       int var1 = str1.compareTo( str2 );\par
       System.out.println("str1 & str2 comparison: "+var1);\par
\par
       int var2 = str1.compareTo( str3 );\par
       System.out.println("str1 & str3 comparison: "+var2);\par
\par
       int var3 = str2.compareTo("compareTo method example");\par
       System.out.println("str2 & string argument comparison: "+var3);\par
   \}\par
\}\par
Output:\par
\par
str1 & str2 comparison: -16\par
str1 & str3 comparison: 0\par
str2 & string argument comparison: 0\par
\par
Java \f1\endash  \f0 String compareToIgnoreCase() Method example\par
STRING HANDLING\par
The method compareToIgnoreCase() is similar to the compareTo() method as it also compares two strings lexicographically. The only difference between them is that compareToIgnoreCase() ignores the case (uppercase or lowercase) while comparing two strings. Similar to compareTo() this method also compares the strings based on the Unicode value of their each character. It returns 0 when the strings are equal else it returns positive or negative value.\par
\par
int compareToIgnoreCase(String str)\par
Example\par
\par
In the below example we have three String literals which have same value but the case is different. string1 is in uppercase, string2 is in lowercase and string3 is a mix of uppercase and lowercase. We are using compareToIgnoreCase() method to compare these strings.\par
\par
public class CompareExample \{\par
   public static void main(String args[]) \{\par
       String string1 = "HELLO";\par
       String string2 = "hello";\par
       String string3 = "Hello";\par
\par
       int var1 = string1.compareToIgnoreCase(string2);\par
       System.out.println("string1 and string2 comparison: "+var1);\par
\par
       int var2 = string1.compareToIgnoreCase(string3);\par
       System.out.println("string1 and string3 comparison: "+var2);\par
\par
       int var3 = string1.compareToIgnoreCase("HeLLo");\par
       System.out.println("string1 and HeLLo comparison: "+var3);\par
   \}\par
\}\par
Output:\par
\par
string1 and string2 comparison: 0\par
string1 and string3 comparison: 0\par
string1 and HeLLo comparison: 0\par
Java \f1\endash  \f0 String regionMatches() Method example\par
STRING HANDLING\par
The method regionMatches() tests if the two Strings are equal. Using this method we can compare the substring of input String with the substring of specified String.\par
\par
Two variants:\par
public boolean regionMatches(int toffset, String other, int ooffset, int len): Case sensitive test.\par
public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len): It has option to consider or ignore the case.\par
\par
Parameters description:\par
ignoreCase\f1\endash  \f0 if true, ignore case when comparing characters.\par
toffset \f1\endash  \f0 the starting offset of the subregion in this string.\par
other \f1\endash  \f0 the string argument.\par
ooffset \f1\endash  \f0 the starting offset of the subregion in the string argument.\par
len \f1\endash  \f0 the number of characters to compare.\par
\par
Example: regionMatches() method\par
\par
public class RegionMatchesExample\{\par
   public static void main(String args[])\{\par
       String str1 = new String("Hello, How are you");\par
       String str2 = new String("How");\par
       String str3 = new String("HOW");\par
\par
       System.out.print("Result of Test1: " );\par
       System.out.println(str1.regionMatches(7, str2, 0, 3));\par
\par
       System.out.print("Result of Test2: " );\par
       System.out.println(str1.regionMatches(7, str3, 0, 3));\par
\par
       System.out.print("Result of Test3: " );\par
       System.out.println(str1.regionMatches(true, 7, str3, 0, 3));\par
   \}\par
\}\par
Output:\par
\par
Result of Test1: true\par
Result of Test2: false\par
Result of Test3: true\par
\par
Java \f1\endash  \f0 String regionMatches() Method example\par
STRING HANDLING\par
The method regionMatches() tests if the two Strings are equal. Using this method we can compare the substring of input String with the substring of specified String.\par
\par
Two variants:\par
public boolean regionMatches(int toffset, String other, int ooffset, int len): Case sensitive test.\par
public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len): It has option to consider or ignore the case.\par
\par
Parameters description:\par
ignoreCase\f1\endash  \f0 if true, ignore case when comparing characters.\par
toffset \f1\endash  \f0 the starting offset of the subregion in this string.\par
other \f1\endash  \f0 the string argument.\par
ooffset \f1\endash  \f0 the starting offset of the subregion in the string argument.\par
len \f1\endash  \f0 the number of characters to compare.\par
\par
Example: regionMatches() method\par
\par
public class RegionMatchesExample\{\par
   public static void main(String args[])\{\par
       String str1 = new String("Hello, How are you");\par
       String str2 = new String("How");\par
       String str3 = new String("HOW");\par
\par
       System.out.print("Result of Test1: " );\par
       System.out.println(str1.regionMatches(7, str2, 0, 3));\par
\par
       System.out.print("Result of Test2: " );\par
       System.out.println(str1.regionMatches(7, str3, 0, 3));\par
\par
       System.out.print("Result of Test3: " );\par
       System.out.println(str1.regionMatches(true, 7, str3, 0, 3));\par
   \}\par
\}\par
Output:\par
\par
Result of Test1: true\par
Result of Test2: false\par
Result of Test3: true\par
\par
\par
\par
\par
\par
Java Regular Expressions (java regex) Tutorial with examples\par
 JAVA TUTORIALS\par
Regular expressions are used for defining String patterns that can be used for searching, manipulating and editing a text. These expressions are also known as Regex (short form of Regular expressions).\par
\par
Lets take an example to understand it better:\par
In the below example, the regular expression .*book.* is used for searching the occurrence of string \f1\ldblquote\f0 book\f1\rdblquote  \f0 in the text.\par
\par
import java.util.regex.*;  \par
class RegexExample1\{  \par
   public static void main(String args[])\{  \par
      String content = "This is Chaitanya " +\par
\tab     "from Beginnersbook.com.";\par
\par
      String pattern = ".*book.*";\par
\par
      boolean isMatch = Pattern.matches(pattern, content);\par
      System.out.println("The text contains 'book'? " + isMatch);\par
   \}\par
\}  \par
Output:\par
\par
The text contains 'book'? true\par
In this tutorial we will learn how to define patterns and how to use them. The java.util.regex API (the package which we need to import while dealing with Regex) has two main classes:\par
\par
1) java.util.regex.Pattern \f1\endash  \f0 Used for defining patterns\par
2) java.util.regex.Matcher \f1\endash  \f0 Used for performing match operations on text using patterns\par
\par
java.util.regex.Pattern class:\par
\par
1) Pattern.matches()\par
We have already seen the usage of this method in the above example where we performed the search for string \f1\ldblquote\f0 book\f1\rdblquote  \f0 in a given text. This is one of simplest and easiest way of searching a String in a text using Regex.\par
\par
String content = "This is a tutorial Website!";\par
String patternString = ".*tutorial.*";\par
boolean isMatch = Pattern.matches(patternString, content);\par
System.out.println("The text contains 'tutorial'? " + isMatch);\par
As you can see we have used matches() method of Pattern class to search the pattern in the given text. The pattern .*tutorial.* allows zero or more characters at the beginning and end of the String \f1\ldblquote\f0 tutorial\f1\rdblquote  \f0 (the expression .* is used for zero and more characters).\par
\par
Limitations: This way we can search a single occurrence of a pattern in a text. For matching multiple occurrences you should use the Pattern.compile() method (discussed in the next section).\par
\par
2) Pattern.compile()\par
In the above example we searched a string \f1\ldblquote\f0 tutorial\f1\rdblquote  \f0 in the text, that is a case sensitive search, however if you want to do a CASE INSENSITIVE search or want to do search multiple occurrences then you may need to first compile the pattern using Pattern.compile() before searching it in text. This is how this method can be used for this case.\par
\par
String content = "This is a tutorial Website!";\par
String patternString = ".*tuToRiAl.";\par
Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);\par
Here we have used a flag Pattern.CASE_INSENSITIVE for case insensitive search, there are several other flags that can be used for different-2 purposes. To read more about such flags refer this document.\par
\par
Now what: We have obtained a Pattern instance but how to match it? For that we would be needing a Matcher instance, which we can get using Pattern.matcher() method. Lets discuss it.\par
\par
3) Pattern.matcher() method\par
In the above section we learnt how to get a Pattern instance using compile() method. Here we will learn How to get Matcher instance from Pattern instance by using matcher() method.\par
\par
String content = "This is a tutorial Website!";\par
String patternString = ".*tuToRiAl.*";\par
Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);\par
Matcher matcher = pattern.matcher(content);\par
boolean isMatched = matcher.matches();\par
System.out.println("Is it a Match?" + isMatched);\par
Output:\par
\par
Is it a Match?true\par
4) Pattern.split()\par
To split a text into multiple strings based on a delimiter (Here delimiter would be specified using regex), we can use Pattern.split() method. This is how it can be done.\par
\par
import java.util.regex.*;  \par
class RegexExample2\{  \par
public static void main(String args[])\{  \par
\tab String text = "ThisIsChaitanya.ItISMyWebsite";\par
    // Pattern for delimiter\par
\tab String patternString = "is";\par
\tab Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);\par
\tab String[] myStrings = pattern.split(text);\par
\tab for(String temp: myStrings)\{\par
\tab     System.out.println(temp);\par
\tab\}\par
\tab System.out.println("Number of split strings: "+myStrings.length);\par
\}\}\par
Output:\par
\par
Th\par
\par
Chaitanya.It\par
MyWebsite\par
Number of split strings: 4\par
The second split String is null in the output.\par
\par
java.util.regex.Matcher Class\par
\par
We already discussed little bit about Matcher class above. Lets recall few things:\par
\par
Creating a Matcher instance\par
String content = "Some text";\par
String patternString = ".*somestring.*";\par
Pattern pattern = Pattern.compile(patternString);\par
Matcher matcher = pattern.matcher(content);\par
Main methods\par
matches(): It matches the regular expression against the whole text passed to the Pattern.matcher() method while creating Matcher instance.\par
\par
...\par
Matcher matcher = pattern.matcher(content);\par
boolean isMatch = matcher.matches();\par
lookingAt(): Similar to matches() method except that it matches the regular expression only against the beginning of the text, while matches() search in the whole text.\par
\par
find(): Searches the occurrences of of the regular expressions in the text. Mainly used when we are searching for multiple occurrences.\par
\par
start() and end(): Both these methods are generally used along with the find() method. They are used for getting the start and end indexes of a match that is being found using find() method.\par
\par
Lets take an example to find out the multiple occurrences using Matcher methods:\par
package beginnersbook.com;\par
import java.util.regex.*;  \par
class RegexExampleMatcher\{  \par
public static void main(String args[])\{  \par
  String content = "ZZZ AA PP AA QQQ AAA ZZ";\par
\par
  String string = "AA";\par
  Pattern pattern = Pattern.compile(string);\par
  Matcher matcher = pattern.matcher(content);\par
\par
  while(matcher.find()) \{\par
     System.out.println("Found at: "+ matcher.start()\par
    \tab\tab + \par
    \tab\tab " - " + matcher.end());\par
  \}\par
\}\par
\}\par
Output:\par
\par
Found at: 4 - 6\par
Found at: 10 - 12\par
Found at: 17 - 19\par
Now we are familiar with Pattern and Matcher class and the process of matching a regular expression against the text. Lets see what kind of various options we have to define a regular expression:\par
\par
1) String Literals\par
Lets say you just want to search a particular string in the text for e.g. \f1\ldblquote\f0 abc\f1\rdblquote  \f0 then we can simply write the code like this: Here text and regex both are same.\par
Pattern.matches("abc", "abc")\par
\par
2) Character Classes\par
A character class matches a single character in the input text against multiple allowed characters in the character class. For example [Cc]haitanya would match all the occurrences of String \f1\ldblquote\f0 chaitanya\f1\rdblquote  \f0 with either lower case or upper case C\f1\rdblquote\f0 . Few more examples:\par
Pattern.matches("[pqr]", "abcd"); It would give false as no p,q or r in the text\par
Pattern.matches("[pqr]", "r"); Return true as r is found\par
Pattern.matches("[pqr]", "pq"); Return false as any one of them can be in text not both.\par
\par
Here is the complete list of various character classes constructs:\par
[abc]: It would match with text if the text is having either one of them(a,b or c) and only once.\par
[^abc]:  Any single character except a, b, or c (^ denote negation)\par
[a-zA-Z]:  a through z, or A through Z, inclusive (range)\par
[a-d[m-p]]:  a through d, or m through p: [a-dm-p] (union)\par
[a-z&&[def]]:  Any one of them (d, e, or f)\par
[a-z&&[^bc]]: a through z, except for b and c: [ad-z] (subtraction)\par
[a-z&&[^m-p]]:  a through z, and not m through p: [a-lq-z] (subtraction)\par
\par
Predefined Character Classes \f1\endash  \f0 Metacharacters\par
These are like short codes which you can use while writing regex.\par
\par
Construct\tab Description\par
.   ->\tab Any character (may or may not match line terminators)\par
\\d  ->\tab A digit: [0-9]\par
\\D  ->\tab A non-digit: [^0-9]\par
\\s  ->\tab A whitespace character: [ \\t\\n\\x0B\\f\\r]\par
\\S  ->\tab A non-whitespace character: [^\\s]\par
\\w  ->\tab A word character: [a-zA-Z_0-9]\par
\\W  ->\tab A non-word character: [^\\w]\par
For e.g.\par
Pattern.matches("\\\\d", "1"); would return true\par
Pattern.matches("{{\field{\*\fldinst{HYPERLINK "\\\\\\\\D"}}{\fldrslt{\\\\D\ul0\cf0}}}}\f0\fs22 ", "z"); return true\par
Pattern.matches(".p", "qp"); return true, dot(.) represent any character\par
\par
Boundary Matchers\par
^\tab Matches the beginning of a line.\par
$\tab Matches then end of a line.\par
\\b\tab Matches a word boundary.\par
\\B\tab Matches a non-word boundary.\par
\\A\tab Matches the beginning of the input text.\par
\\G\tab Matches the end of the previous match\par
\\Z\tab Matches the end of the input text except the final terminator if any.\par
\\z\tab Matches the end of the input text.\par
For e.g.\par
Pattern.matches("^Hello$", "Hello"): return true, Begins and ends with Hello\par
Pattern.matches("^Hello$", "Namaste! Hello"): return false, does not begin with Hello\par
Pattern.matches("^Hello$", "Hello Namaste!"): return false, Does not end with Hello\par
\par
Quantifiers\par
Greedy\tab Reluctant\tab Possessive\tab Matches\par
X?\tab X??\tab X?+\tab Matches X once, or not at all (0 or 1 time).\par
X*\tab X*?\tab X*+\tab Matches X zero or more times.\par
X+\tab X+?\tab X++\tab Matches X one or more times.\par
X\{n\}\tab X\{n\}?\tab X\{n\}+\tab Matches X exactly n times.\par
X\{n,\}\tab X\{n,\}?\tab X\{n,\}+\tab Matches X at least n times.\par
X\{n, m)\tab X\{n, m)? X\{n, m)+\tab Matches X at least n time, but at most m times.\par
Few examples\par
import java.util.regex.*;  \par
class RegexExample\{  \par
public static void main(String args[])\{  \par
   // It would return true if string matches exactly "tom"\par
   System.out.println(\par
     Pattern.matches("tom", "Tom")); //False\par
\tab\par
   /* returns true if the string matches exactly \par
    * "tom" or "Tom"\par
    */\par
   System.out.println(\par
     Pattern.matches("[Tt]om", "Tom")); //True\par
   System.out.println(\par
     Pattern.matches("[Tt]om", "Tom")); //True\par
\tab\par
   /* Returns true if the string matches exactly "tim" \par
    * or "Tim" or "jin" or "Jin"\par
    */\par
   System.out.println(\par
     Pattern.matches("[tT]im|[jJ]in", "Tim"));//True\par
   System.out.println(\par
     Pattern.matches("[tT]im|[jJ]in", "jin"));//True\par
\tab\par
   /* returns true if the string contains "abc" at \par
    * any place\par
    */\par
   System.out.println(\par
     Pattern.matches(".*abc.*", "deabcpq"));//True\par
\tab\par
   /* returns true if the string does not have a \par
    * number at the beginning\par
    */\par
   System.out.println(\par
     Pattern.matches("^[^\\\\d].*", "123abc")); //False\par
   System.out.println(\par
     Pattern.matches("^[^\\\\d].*", "abc123")); //True\par
\tab\par
   // returns true if the string contains of three letters\par
   System.out.println(\par
     Pattern.matches("[a-zA-Z][a-zA-Z][a-zA-Z]", "aPz"));//True\par
   System.out.println(\par
     Pattern.matches("[a-zA-Z][a-zA-Z][a-zA-Z]", "aAA"));//True\par
   System.out.println(\par
     Pattern.matches("[a-zA-Z][a-zA-Z][a-zA-Z]", "apZx"));//False\par
\tab\par
   // returns true if the string contains 0 or more non-digits\par
   System.out.println(\par
     Pattern.matches("\\\\D*", "abcde")); //True\par
   System.out.println(\par
     Pattern.matches("\\\\D*", "abcde123")); //False\par
\tab\par
   /* Boundary Matchers example\par
    * ^ denotes start of the line\par
    * $ denotes end of the line\par
    */\par
   System.out.println(\par
     Pattern.matches("^This$", "This is Chaitanya")); //False\par
   System.out.println(\par
     Pattern.matches("^This$", "This")); //True\par
   System.out.println(\par
     Pattern.matches("^This$", "Is This Chaitanya")); //False\par
\}\par
\}\par
\par
\par
Java \f1\endash  \f0 String matches() Method example\par
STRING HANDLING\par
Method matches() checks whether the String is matching with the specified regular expression. If the String fits in the specified regular expression then this method returns true else it returns false. Below is the syntax of the method:\par
\par
public boolean matches(String regex)\par
It throws PatternSyntaxException \f1\endash  \f0 if the specified regular expression is not valid.\par
\par
Example: matches() method\par
\par
In this example we have a String and three regular expressions. We are matching the regular expressions(regex) with the input String using the matches() method.\par
\par
public class MatchesExample\{\par
   public static void main(String args[])\{\par
       String str = new String("Java String Methods");\par
\par
       System.out.print("Regex: (.*)String(.*) matches string? " );\par
       System.out.println(str.matches("(.*)String(.*)"));\par
\par
       System.out.print("Regex: (.*)Strings(.*) matches string? " );\par
       System.out.println(str.matches("(.*)Strings(.*)"));\par
\par
       System.out.print("Regex: (.*)Methods matches string? " );\par
       System.out.println(str.matches("(.*)Methods"));\par
   \}\par
\}\par
Output:\par
\par
Regex: (.*)String(.*) matches string? true\par
Regex: (.*)Strings(.*) matches string? false\par
Regex: (.*)Methods matches string? true\par
\par
\par
Java Enum Tutorial with examples\par
 JAVA TUTORIALS\par
An enum is a special type of data type which is basically a collection (set) of constants. In this tutorial we will learn how to use enums in Java and what are the possible scenarios where we can use them.\par
\par
This is how we define Enum\par
public enum Directions\{\par
  EAST, \par
  WEST, \par
  NORTH, \par
  SOUTH\par
\}\par
Here we have a variable Directions of enum type, which is a collection of four constants EAST, WEST, NORTH and SOUTH.\par
\par
How to assign value to a enum type?\par
\par
Directions dir = Directions.NORTH;\par
The variable dir is of type Directions (that is a enum type). This variable can take any value, out of the possible four values (EAST, WEST, NORTH, SOUTH). In this case it is set to NORTH.\par
\par
Use of Enum types in if-else statements\par
This is how we can use an enum variable in a if-else logic.\par
\par
/* You can assign any value here out of\par
 * EAST, WEST, NORTH, SOUTH. Just for the\par
 * sake of example, I'm assigning to NORTH\par
 */\par
Directions dir = Directions.NORTH;  \par
\par
if(dir == Directions.EAST) \{\par
  // Do something. Write your logic\par
\} else if(dir == Directions.WEST) \{\par
     // Do something else\par
  \} else if(dir == Directions.NORTH) \{\par
     // Do something \par
    \} else \{\par
        /* Do Something. Write logic for \par
         * the remaining constant SOUTH\par
         */ \par
      \}\par
Enum Example\par
\par
This is just an example to demonstrate the use enums. If you understand the core part and basics, you would be able to write your own logic based on the requirement.\par
\par
public enum Directions\{\par
\tab   EAST, \par
\tab   WEST, \par
\tab   NORTH, \par
\tab   SOUTH\par
\}\par
public class EnumDemo\par
\{\par
   public static void main(String args[])\{\par
\tab Directions dir = Directions.NORTH;  \par
\tab if(dir == Directions.EAST) \{\par
\tab     System.out.println("Direction: East");\par
\tab\} else if(dir == Directions.WEST) \{\par
\tab     System.out.println("Direction: West");\par
\tab   \} else if(dir == Directions.NORTH) \{\par
\tab       System.out.println("Direction: North");\par
  \tab     \} else \{\par
\tab\tab System.out.println("Direction: South");\par
\tab       \}\par
   \}\par
\}\par
Output:\par
\par
Direction: North\par
Use of Enum in Switch-Case Statements\par
Here is the example to demonstrate the use of enums in switch-case statements.\par
\par
public enum Directions\{\par
\tab   EAST, \par
\tab   WEST, \par
\tab   NORTH, \par
\tab   SOUTH\par
\}\par
public class EnumDemo\par
\{\par
   Directions dir;\par
   public EnumDemo(Directions dir) \{\par
      this.dir = dir;\par
   \}\par
   public void getMyDirection() \{\par
     switch (dir) \{\par
       case EAST:\par
          System.out.println("In East Direction");\par
          break;\par
                    \par
       case WEST:\par
          System.out.println("In West Direction");\par
          break;\par
                         \par
       case NORTH: \par
          System.out.println("In North Direction");\par
          break;\par
                        \par
       default:\par
          System.out.println("In South Direction");\par
          break;\par
     \}\par
   \}\par
    \par
    public static void main(String[] args) \{\par
        EnumDemo obj1 = new EnumDemo(Directions.EAST);\par
        obj1.getMyDirection();\par
        EnumDemo obj2 = new EnumDemo(Directions.SOUTH);\par
        obj2.getMyDirection();\par
    \}\par
\}\par
Output:\par
\par
In East Direction\par
In South Direction\par
How to iterate through an Enum variable\par
class EnumDemo\par
\{\par
    public static void main(String[] args) \{\par
    \tab for (Directions dir : Directions.values()) \{\par
    \tab     System.out.println(dir);\par
    \tab\}\par
    \}\par
\}\par
This code would display all the four constants.\par
\par
Enum Fields and Methods\par
\par
Lets take an example first then we will discuss it in detail:\par
\par
public enum Directions\{\par
  EAST ("E"), \par
  WEST ("W"), \par
  NORTH ("N"), \par
  SOUTH ("S")\par
  ; \par
  /* Important Note: Must have semicolon at\par
   * the end when there is a enum field or method\par
   */\par
  private final String shortCode;\par
\tab   \par
  Directions(String code) \{\par
      this.shortCode = code;\par
  \}\par
\tab   \par
  public String getDirectionCode() \{\par
      return this.shortCode;\par
  \}\par
\}\par
public class EnumDemo\par
\{\par
    public static void main(String[] args) \{\par
    \tab Directions dir = Directions.SOUTH;\par
    \tab System.out.println(dir.getDirectionCode());\par
    \tab Directions dir2 = Directions.EAST;\par
    \tab System.out.println(dir2.getDirectionCode());\par
    \}\par
\}\par
Output:\par
\par
S\par
E\par
As you can see in this example we have a field shortCode for each of the constant, along with a method getDirectionCode() which is basically a getter method for this field. When we define a constant like this EAST ("E"), it calls the enum constructor (Refer the constructor Directions in the above example) with the passed argument. This way the passed value is set as an value for the field of the corresponding enum\f1\rquote\f0 s constant [EAST(\f1\ldblquote\f0 E\f1\rdblquote\f0 ) => Would call constructor Directions(\f1\ldblquote\f0 E\f1\rdblquote\f0 ) => this.shortCode = code => this.shortCode = \f1\ldblquote\f0 E\f1\rdblquote  \f0 => shortCode field of constant EAST is set to \f1\ldblquote\f0 E\f1\rdblquote\f0 ].\par
\par
Important points to Note:\par
1) While defining Enums, the constants should be declared first, prior to any fields or methods.\par
2) When there are fields and methods declared inside Enum, the list of enum constants must end with a semicolon(;).\par
\par
\par
Java Annotations tutorial with examples\par
 JAVA TUTORIALS\par
Java Annotations allow us to add metadata information into our source code, although they are not a part of the program itself. Annotations were added to the java from JDK 5. Annotation has no direct effect on the operation of the code they annotate (i.e. it does not affect the execution of the program).\par
\par
In this tutorial we are going to cover following topics: Usage of annotations, how to apply annotations, what predefined annotation types are available in the Java and how to create custom annotations.\par
\par
What\f1\rquote\f0 s the use of Annotations?\par
\par
1) Instructions to the compiler: There are three built-in annotations available in Java (@Deprecated, @Override & @SuppressWarnings) that can be used for giving certain instructions to the compiler. For example the @override annotation is used for instructing compiler that the annotated method is overriding the method. More about these built-in annotations with example is discussed in the next sections of this article.\par
\par
2) Compile-time instructors: Annotations can provide compile-time instructions to the compiler that can be further used by sofware build tools for generating code, XML files etc.\par
\par
3) Runtime instructions: We can define annotations to be available at runtime which we can access using java reflection and can be used to give instructions to the program at runtime. We will discuss this with the help of an example, later in this same post.\par
\par
Annotations basics\par
\par
An annotation always starts with the symbol @ followed by the annotation name. The symbol @ indicates to the compiler that this is an annotation.\par
\par
For e.g. @Override\par
Here @ symbol represents that this is an annotation and the Override is the name of this annotation.\par
\par
Where we can use annotations?\par
Annotations can be applied to the classes, interfaces, methods and fields. For example the below annotation is being applied to the method.\par
\par
@Override\par
void myMethod() \{ \par
    //Do something \par
\}\par
What this annotation is exactly doing here is explained in the next section but to be brief it is instructing compiler that myMethod() is a overriding method which is overriding the method (myMethod()) of super class.\par
\par
Built-in Annotations in Java\par
\par
Java has three built-in annotations:\par
\par
@Override\par
@Deprecated\par
@SuppressWarnings\par
1) @Override:\par
While overriding a method in the child class, we should use this annotation to mark that method. This makes code readable and avoid maintenance issues, such as: while changing the method signature of parent class, you must change the signature in child classes (where this annotation is being used) otherwise compiler would throw compilation error. This is difficult to trace when you haven\f1\rquote\f0 t used this annotation.\par
\par
Example:\par
\par
public class MyParentClass \{\par
\par
    public void justaMethod() \{\par
        System.out.println("Parent class method");\par
    \}\par
\}\par
\par
\par
public class MyChildClass extends MyParentClass \{\par
\par
    @Override\par
    public void justaMethod() \{\par
        System.out.println("Child class method");\par
    \}\par
\}\par
I believe the example is self explanatory. To read more about this annotation, refer this article: @Override built-in annotation.\par
\par
2) @Deprecated\par
@Deprecated annotation indicates that the marked element (class, method or field) is deprecated and should no longer be used. The compiler generates a warning whenever a program uses a method, class, or field that has already been marked with the @Deprecated annotation. When an element is deprecated, it should also be documented using the Javadoc @deprecated tag, as shown in the following example. Make a note of case difference with @Deprecated and @deprecated. @deprecated is used for documentation purpose.\par
\par
Example:\par
\par
/**\par
 * @deprecated\par
 * reason for why it was deprecated\par
 */\par
@Deprecated\par
public void anyMethodHere()\{\par
    // Do something\par
\}\par
Now, whenever any program would use this method, the compiler would generate a warning. To read more about this annotation, refer this article: Java \f1\endash  \f0 @Deprecated annotation.\par
\par
3) @SuppressWarnings\par
This annotation instructs compiler to ignore specific warnings. For example in the below code, I am calling a deprecated method (lets assume that the method deprecatedMethod() is marked with @Deprecated annotation) so the compiler should generate a warning, however I am using @@SuppressWarnings annotation that would suppress that deprecation warning.\par
\par
@SuppressWarnings("deprecation")\par
    void myMethod() \{\par
        myObject.deprecatedMethod();\par
\}\par
Creating Custom Annotations\par
\par
Annotations are created by using @interface, followed by annotation name as shown in the below example.\par
An annotation can have elements as well. They look like methods. For example in the below code, we have four elements. We should not provide implementation for these elements.\par
All annotations extends java.lang.annotation.Annotation interface. Annotations cannot include any extends clause.\par
import java.lang.annotation.Documented;\par
import java.lang.annotation.ElementType;\par
import java.lang.annotation.Inherited;\par
import java.lang.annotation.Retention;\par
import java.lang.annotation.RetentionPolicy;\par
import java.lang.annotation.Target;\par
 \par
@Documented\par
@Target(ElementType.METHOD)\par
@Inherited\par
@Retention(RetentionPolicy.RUNTIME)\par
public @interface MyCustomAnnotation\{\par
    int studentAge() default 18;\par
    String studentName();\par
    String stuAddress();\par
    String stuStream() default "CSE";\par
\}\par
Note: All the elements that have default values set while creating annotations can be skipped while using annotation. For example if I\f1\rquote\f0 m applying the above annotation to a class then I would do it like this:\par
\par
@MyCustomAnnotation(\par
    studentName="Chaitanya",\par
    stuAddress="Agra, India"\par
)\par
public class MyClass \{\par
...\par
\}\par
As you can see, we have not given any value to the studentAge and stuStream elements as it is optional to set the values of these elements (default values already been set in Annotation definition, but if you want you can assign new value while using annotation just the same way as we did for other elements). However we have to provide the values of other elements (the elements that do not have default values set) while using annotation.\par
\par
Note: We can also have array elements in an annotation. This is how we can use them:\par
Annotation definition:\par
\par
@interface MyCustomAnnotation \{\par
    int      count();\par
    String[] books();\par
\}\par
Usage:\par
\par
@MyCustomAnnotation(\par
    count=3,\par
    books=\{"C++", "Java"\}\par
)\par
public class MyClass \{\par
\par
\}\par
Lets back to the topic again: In the custom annotation example we have used these four annotations: @Documented, @Target, @Inherited & @Retention. Lets discuss them in detail.\par
\par
@Documented\par
@Documented annotation indicates that elements using this annotation should be documented by JavaDoc. For example:\par
\par
java.lang.annotation.Documented\par
@Documented\par
public @interface MyCustomAnnotation \{\par
  //Annotation body\par
\}\par
@MyCustomAnnotation\par
public class MyClass \{ \par
     //Class body\par
\}\par
While generating the javadoc for class MyClass, the annotation @MyCustomAnnotation would be included in that.\par
\par
@Target\par
It specifies where we can use the annotation. For example: In the below code, we have defined the target type as METHOD which means the below annotation can only be used on methods.\par
\par
import java.lang.annotation.ElementType;\par
import java.lang.annotation.Target;\par
\par
@Target(\{ElementType.METHOD\})\par
public @interface MyCustomAnnotation \{\par
\par
\}\par
public class MyClass \{\par
   @MyCustomAnnotation\par
   public void myMethod()\par
   \{\par
       //Doing something\par
   \}\par
\}\par
Note: 1) If you do not define any Target type that means annotation can be applied to any element.\par
2) Apart from ElementType.METHOD, an annotation can have following possible Target values.\par
ElementType.METHOD\par
ElementType.PACKAGE\par
ElementType.PARAMETER\par
ElementType.TYPE\par
ElementType.ANNOTATION_TYPE\par
ElementType.CONSTRUCTOR\par
ElementType.LOCAL_VARIABLE\par
ElementType.FIELD\par
\par
@Inherited\par
The @Inherited annotation signals that a custom annotation used in a class should be inherited by all of its sub classes. For example:\par
\par
java.lang.annotation.Inherited\par
\par
@Inherited\par
public @interface MyCustomAnnotation \{\par
\par
\}\par
@MyCustomAnnotation\par
public class MyParentClass \{ \par
  ... \par
\}\par
public class MyChildClass extends MyParentClass \{ \par
   ... \par
\}\par
Here the class MyParentClass is using annotation @MyCustomAnnotation which is marked with @inherited annotation. It means the sub class MyChildClass inherits the @MyCustomAnnotation.\par
\par
@Retention\par
It indicates how long annotations with the annotated type are to be retained.\par
\par
import java.lang.annotation.Retention;\par
import java.lang.annotation.RetentionPolicy;\par
\par
@Retention(RetentionPolicy.RUNTIME)\par
@interface MyCustomAnnotation \{\par
    \par
\}\par
Here we have used RetentionPolicy.RUNTIME. There are two other options as well. Lets see what do they mean:\par
RetentionPolicy.RUNTIME: The annotation should be available at runtime, for inspection via java reflection.\par
RetentionPolicy.CLASS: The annotation would be in the .class file but it would not be available at runtime.\par
RetentionPolicy.SOURCE: The annotation would be available in the source code of the program, it would neither be in the .class file nor be available at the runtime.\par
\par
That\f1\rquote\f0 s all for this topic \f1\ldblquote\f0 Java Annotation\f1\rdblquote\f0 . Should you have any questions, feel free to drop a line below.\par
\par
JSON Tutorial: Learn JSON in 10 Minutes\par
JSON\par
JSON stands for JavaScript Object Notation. JSON objects are used for transferring data between server and client, XML serves the same purpose. However JSON objects have several advantages over XML and we are going to discuss them in this tutorial along with JSON concepts and its usages.\par
\par
Let\f1\rquote\f0 s have a look at the piece of a JSON data: It basically has key-value pairs.\par
\par
var chaitanya = \{\par
   "firstName" : "Chaitanya",\par
   "lastName" : "Singh",\par
   "age" :  "28"\par
\};\par
Features of JSON:\par
\par
It is light-weight\par
It is language independent\par
Easy to read and write\par
Text based, human readable data exchange format\par
Why use JSON?\par
\par
Standard Structure: As we have seen so far that JSON objects are having a standard structure that makes developers job easy to read and write code, because they know what to expect from JSON.\par
\par
Light weight: When working with AJAX, it is important to load the data quickly and asynchronously without requesting the page re-load. Since JSON is light weighted, it becomes easier to get and load the requested data quickly.\par
\par
Scalable: JSON is language independent, which means it can work well with most of the modern programming language. Let\f1\rquote\f0 s say if we need to change the server side language, in that case it would be easier for us to go ahead with that change as JSON structure is same for all the languages.\par
\par
JSON vs. XML\par
\par
Let see how JSON and XML look when we store the records of 4 students in a text based format so that we can retrieve it later when required.\par
\par
JSON style:\par
\par
\{"students":[\par
   \{"name":"John", "age":"23", "city":"Agra"\},\par
   \{"name":"Steve", "age":"28", "city":"Delhi"\},\par
   \{"name":"Peter", "age":"32", "city":"Chennai"\},\par
   \{"name":"Chaitanya", "age":"28", "city":"Bangalore"\}\par
]\}\par
XML style:\par
\par
<students>\par
  <student>\par
    <name>John</name> <age>23</age> <city>Agra</city>\par
  </student>\par
  <student>\par
    <name>Steve</name> <age>28</age> <city>Delhi</city>\par
  </student>\par
  <student>\par
    <name>Peter</name> <age>32</age> <city>Chennai</city>\par
  </student>\par
  <student>\par
    <name>Chaitanya</name> <age>28</age> <city>Bangalore</city>\par
  </student>\par
</students>\par
As you can clearly see JSON is much more light-weight compared to XML. Also, in JSON we take advantage of arrays that is not available in XML.\par
\par
JSON data structure types and how to read them:\par
\par
JSON objects\par
JSON objects in array\par
Nesting of JSON objects\par
1) JSON objects:\par
var chaitanya = \{\par
  "name" : "Chaitanya Singh",\par
  "age" = "28",\par
  "website" = "beginnersbook"\par
\};\par
The above text creates an object that we can access using the variable chaitanya. Inside an object we can have any number of key-value pairs like we have above. We can access the information out of a JSON object like this:\par
\par
document.writeln("The name is:  " +chaitanya.name);\par
document.writeln("his age is: " + chaitanya.age);\par
document.writeln("his website is: "+ chaitanya.website);\par
2) JSON objects in array\par
In the above example we have stored the information of one person in a JSON object suppose we want to store the information of more than one person; in that case we can have an array of objects.\par
\par
var students = [\{\par
   "name" : "Steve",\par
   "age" :  "29",\par
   "gender" : "male"\par
\par
\},\par
\{\par
   "name" : "Peter",\par
   "age" : "32",\par
   "gender" : "male"\par
\par
\},\par
\{\par
   "name" : "Sophie",\par
   "age" : "27",\par
   "gender" : "female"\par
\}];\par
To access the information out of this array, we do write the code like this:\par
\par
document.writeln(students[0].age); //output would be: 29\par
document.writeln(students[2].name); //output: Sophie\par
You got the point, right? Let\f1\rquote\f0 s carry on with the next type.\par
\par
3) Nesting of JSON objects:\par
Another way of doing the same thing that we have done above.\par
\par
var students = \{\par
  "steve" : \{\par
  "name" : "Steve",\par
  "age" :  "29",\par
  "gender" : "male" \par
\},\par
\par
"pete" : \{\par
  "name" : "Peter",\par
  "age" : "32",\par
  "gender" : "male"\par
\},\par
\par
"sop" : \{\par
  "name" : "Sophie",\par
  "age" : "27",\par
  "gender" : "female"\par
\}\par
\}\par
Do like this to access the info from above nested JSON objects:\par
\par
document.writln(students.steve.age); //output: 29\par
document.writeln(students.sop.gender); //output: female\par
JSON & JavaScript:\par
\par
JSON is considered as a subset of JavaScript but that does not mean that JSON cannot be used with other languages. In fact it works well with PHP, Perl, Python, Ruby, Java, Ajax and many more.\par
\par
Just to demonstrate how JSON can be used along with JavaScript, here is an example:\par
If you have gone though the above tutorial, you are familiar with the JSON structures. A JSON file type is .json\par
\par
How to read data from json file and convert it into a JavaScript object?\par
We have two ways to do this.\par
1) Using eval function, but this is not suggested due to security reasons (malicious data can be sent from the server to the client and then eval in the client script with harmful effects).\par
2) Using JSON parser: No security issues plus it is faster than eval. Here is how to use it:\par
\par
var chaitanya = \{\par
"name" : "Chaitanya Singh",\par
"age" = "28",\par
"website" = "beginnersbook"\par
\};\par
We are converting the above JSON object to javascript object using JSON parser:\par
\par
var myJSObject = JSON.parse(chaitanya);\par
How to convert JavaScript object to JSON text?\par
By using method stringify\par
\par
var jsonText= JSON.stringify(myJSObject);\par
I guess the 10 minutes are over. Bookmark this page as I will be adding more tutorials on JSON and will add the links to those tutorials here.\par
\par
\par
\par
Java Regular Expressions (java regex) Tutorial with examples\par
 JAVA TUTORIALS\par
Regular expressions are used for defining String patterns that can be used for searching, manipulating and editing a text. These expressions are also known as Regex (short form of Regular expressions).\par
\par
Lets take an example to understand it better:\par
In the below example, the regular expression .*book.* is used for searching the occurrence of string \f1\ldblquote\f0 book\f1\rdblquote  \f0 in the text.\par
\par
import java.util.regex.*;  \par
class RegexExample1\{  \par
   public static void main(String args[])\{  \par
      String content = "This is Chaitanya " +\par
\tab     "from Beginnersbook.com.";\par
\par
      String pattern = ".*book.*";\par
\par
      boolean isMatch = Pattern.matches(pattern, content);\par
      System.out.println("The text contains 'book'? " + isMatch);\par
   \}\par
\}  \par
Output:\par
\par
The text contains 'book'? true\par
In this tutorial we will learn how to define patterns and how to use them. The java.util.regex API (the package which we need to import while dealing with Regex) has two main classes:\par
\par
1) java.util.regex.Pattern \f1\endash  \f0 Used for defining patterns\par
2) java.util.regex.Matcher \f1\endash  \f0 Used for performing match operations on text using patterns\par
\par
java.util.regex.Pattern class:\par
\par
1) Pattern.matches()\par
We have already seen the usage of this method in the above example where we performed the search for string \f1\ldblquote\f0 book\f1\rdblquote  \f0 in a given text. This is one of simplest and easiest way of searching a String in a text using Regex.\par
\par
String content = "This is a tutorial Website!";\par
String patternString = ".*tutorial.*";\par
boolean isMatch = Pattern.matches(patternString, content);\par
System.out.println("The text contains 'tutorial'? " + isMatch);\par
As you can see we have used matches() method of Pattern class to search the pattern in the given text. The pattern .*tutorial.* allows zero or more characters at the beginning and end of the String \f1\ldblquote\f0 tutorial\f1\rdblquote  \f0 (the expression .* is used for zero and more characters).\par
\par
Limitations: This way we can search a single occurrence of a pattern in a text. For matching multiple occurrences you should use the Pattern.compile() method (discussed in the next section).\par
\par
2) Pattern.compile()\par
In the above example we searched a string \f1\ldblquote\f0 tutorial\f1\rdblquote  \f0 in the text, that is a case sensitive search, however if you want to do a CASE INSENSITIVE search or want to do search multiple occurrences then you may need to first compile the pattern using Pattern.compile() before searching it in text. This is how this method can be used for this case.\par
\par
String content = "This is a tutorial Website!";\par
String patternString = ".*tuToRiAl.";\par
Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);\par
Here we have used a flag Pattern.CASE_INSENSITIVE for case insensitive search, there are several other flags that can be used for different-2 purposes. To read more about such flags refer this document.\par
\par
Now what: We have obtained a Pattern instance but how to match it? For that we would be needing a Matcher instance, which we can get using Pattern.matcher() method. Lets discuss it.\par
\par
3) Pattern.matcher() method\par
In the above section we learnt how to get a Pattern instance using compile() method. Here we will learn How to get Matcher instance from Pattern instance by using matcher() method.\par
\par
String content = "This is a tutorial Website!";\par
String patternString = ".*tuToRiAl.*";\par
Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);\par
Matcher matcher = pattern.matcher(content);\par
boolean isMatched = matcher.matches();\par
System.out.println("Is it a Match?" + isMatched);\par
Output:\par
\par
Is it a Match?true\par
4) Pattern.split()\par
To split a text into multiple strings based on a delimiter (Here delimiter would be specified using regex), we can use Pattern.split() method. This is how it can be done.\par
\par
import java.util.regex.*;  \par
class RegexExample2\{  \par
public static void main(String args[])\{  \par
\tab String text = "ThisIsChaitanya.ItISMyWebsite";\par
    // Pattern for delimiter\par
\tab String patternString = "is";\par
\tab Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);\par
\tab String[] myStrings = pattern.split(text);\par
\tab for(String temp: myStrings)\{\par
\tab     System.out.println(temp);\par
\tab\}\par
\tab System.out.println("Number of split strings: "+myStrings.length);\par
\}\}\par
Output:\par
\par
Th\par
\par
Chaitanya.It\par
MyWebsite\par
Number of split strings: 4\par
The second split String is null in the output.\par
\par
java.util.regex.Matcher Class\par
\par
We already discussed little bit about Matcher class above. Lets recall few things:\par
\par
Creating a Matcher instance\par
String content = "Some text";\par
String patternString = ".*somestring.*";\par
Pattern pattern = Pattern.compile(patternString);\par
Matcher matcher = pattern.matcher(content);\par
Main methods\par
matches(): It matches the regular expression against the whole text passed to the Pattern.matcher() method while creating Matcher instance.\par
\par
...\par
Matcher matcher = pattern.matcher(content);\par
boolean isMatch = matcher.matches();\par
lookingAt(): Similar to matches() method except that it matches the regular expression only against the beginning of the text, while matches() search in the whole text.\par
\par
find(): Searches the occurrences of of the regular expressions in the text. Mainly used when we are searching for multiple occurrences.\par
\par
start() and end(): Both these methods are generally used along with the find() method. They are used for getting the start and end indexes of a match that is being found using find() method.\par
\par
Lets take an example to find out the multiple occurrences using Matcher methods:\par
package beginnersbook.com;\par
import java.util.regex.*;  \par
class RegexExampleMatcher\{  \par
public static void main(String args[])\{  \par
  String content = "ZZZ AA PP AA QQQ AAA ZZ";\par
\par
  String string = "AA";\par
  Pattern pattern = Pattern.compile(string);\par
  Matcher matcher = pattern.matcher(content);\par
\par
  while(matcher.find()) \{\par
     System.out.println("Found at: "+ matcher.start()\par
    \tab\tab + \par
    \tab\tab " - " + matcher.end());\par
  \}\par
\}\par
\}\par
Output:\par
\par
Found at: 4 - 6\par
Found at: 10 - 12\par
Found at: 17 - 19\par
Now we are familiar with Pattern and Matcher class and the process of matching a regular expression against the text. Lets see what kind of various options we have to define a regular expression:\par
\par
1) String Literals\par
Lets say you just want to search a particular string in the text for e.g. \f1\ldblquote\f0 abc\f1\rdblquote  \f0 then we can simply write the code like this: Here text and regex both are same.\par
Pattern.matches("abc", "abc")\par
\par
2) Character Classes\par
A character class matches a single character in the input text against multiple allowed characters in the character class. For example [Cc]haitanya would match all the occurrences of String \f1\ldblquote\f0 chaitanya\f1\rdblquote  \f0 with either lower case or upper case C\f1\rdblquote\f0 . Few more examples:\par
Pattern.matches("[pqr]", "abcd"); It would give false as no p,q or r in the text\par
Pattern.matches("[pqr]", "r"); Return true as r is found\par
Pattern.matches("[pqr]", "pq"); Return false as any one of them can be in text not both.\par
\par
Here is the complete list of various character classes constructs:\par
[abc]: It would match with text if the text is having either one of them(a,b or c) and only once.\par
[^abc]:  Any single character except a, b, or c (^ denote negation)\par
[a-zA-Z]:  a through z, or A through Z, inclusive (range)\par
[a-d[m-p]]:  a through d, or m through p: [a-dm-p] (union)\par
[a-z&&[def]]:  Any one of them (d, e, or f)\par
[a-z&&[^bc]]: a through z, except for b and c: [ad-z] (subtraction)\par
[a-z&&[^m-p]]:  a through z, and not m through p: [a-lq-z] (subtraction)\par
\par
Predefined Character Classes \f1\endash  \f0 Metacharacters\par
These are like short codes which you can use while writing regex.\par
\par
Construct\tab Description\par
.   ->\tab Any character (may or may not match line terminators)\par
\\d  ->\tab A digit: [0-9]\par
\\D  ->\tab A non-digit: [^0-9]\par
\\s  ->\tab A whitespace character: [ \\t\\n\\x0B\\f\\r]\par
\\S  ->\tab A non-whitespace character: [^\\s]\par
\\w  ->\tab A word character: [a-zA-Z_0-9]\par
\\W  ->\tab A non-word character: [^\\w]\par
For e.g.\par
Pattern.matches("\\\\d", "1"); would return true\par
Pattern.matches("{{\field{\*\fldinst{HYPERLINK "\\\\\\\\D"}}{\fldrslt{\\\\D\ul0\cf0}}}}\f0\fs22 ", "z"); return true\par
Pattern.matches(".p", "qp"); return true, dot(.) represent any character\par
\par
Boundary Matchers\par
^\tab Matches the beginning of a line.\par
$\tab Matches then end of a line.\par
\\b\tab Matches a word boundary.\par
\\B\tab Matches a non-word boundary.\par
\\A\tab Matches the beginning of the input text.\par
\\G\tab Matches the end of the previous match\par
\\Z\tab Matches the end of the input text except the final terminator if any.\par
\\z\tab Matches the end of the input text.\par
For e.g.\par
Pattern.matches("^Hello$", "Hello"): return true, Begins and ends with Hello\par
Pattern.matches("^Hello$", "Namaste! Hello"): return false, does not begin with Hello\par
Pattern.matches("^Hello$", "Hello Namaste!"): return false, Does not end with Hello\par
\par
Quantifiers\par
Greedy\tab Reluctant\tab Possessive\tab Matches\par
X?\tab X??\tab X?+\tab Matches X once, or not at all (0 or 1 time).\par
X*\tab X*?\tab X*+\tab Matches X zero or more times.\par
X+\tab X+?\tab X++\tab Matches X one or more times.\par
X\{n\}\tab X\{n\}?\tab X\{n\}+\tab Matches X exactly n times.\par
X\{n,\}\tab X\{n,\}?\tab X\{n,\}+\tab Matches X at least n times.\par
X\{n, m)\tab X\{n, m)? X\{n, m)+\tab Matches X at least n time, but at most m times.\par
Few examples\par
import java.util.regex.*;  \par
class RegexExample\{  \par
public static void main(String args[])\{  \par
   // It would return true if string matches exactly "tom"\par
   System.out.println(\par
     Pattern.matches("tom", "Tom")); //False\par
\tab\par
   /* returns true if the string matches exactly \par
    * "tom" or "Tom"\par
    */\par
   System.out.println(\par
     Pattern.matches("[Tt]om", "Tom")); //True\par
   System.out.println(\par
     Pattern.matches("[Tt]om", "Tom")); //True\par
\tab\par
   /* Returns true if the string matches exactly "tim" \par
    * or "Tim" or "jin" or "Jin"\par
    */\par
   System.out.println(\par
     Pattern.matches("[tT]im|[jJ]in", "Tim"));//True\par
   System.out.println(\par
     Pattern.matches("[tT]im|[jJ]in", "jin"));//True\par
\tab\par
   /* returns true if the string contains "abc" at \par
    * any place\par
    */\par
   System.out.println(\par
     Pattern.matches(".*abc.*", "deabcpq"));//True\par
\tab\par
   /* returns true if the string does not have a \par
    * number at the beginning\par
    */\par
   System.out.println(\par
     Pattern.matches("^[^\\\\d].*", "123abc")); //False\par
   System.out.println(\par
     Pattern.matches("^[^\\\\d].*", "abc123")); //True\par
\tab\par
   // returns true if the string contains of three letters\par
   System.out.println(\par
     Pattern.matches("[a-zA-Z][a-zA-Z][a-zA-Z]", "aPz"));//True\par
   System.out.println(\par
     Pattern.matches("[a-zA-Z][a-zA-Z][a-zA-Z]", "aAA"));//True\par
   System.out.println(\par
     Pattern.matches("[a-zA-Z][a-zA-Z][a-zA-Z]", "apZx"));//False\par
\tab\par
   // returns true if the string contains 0 or more non-digits\par
   System.out.println(\par
     Pattern.matches("\\\\D*", "abcde")); //True\par
   System.out.println(\par
     Pattern.matches("\\\\D*", "abcde123")); //False\par
\tab\par
   /* Boundary Matchers example\par
    * ^ denotes start of the line\par
    * $ denotes end of the line\par
    */\par
   System.out.println(\par
     Pattern.matches("^This$", "This is Chaitanya")); //False\par
   System.out.println(\par
     Pattern.matches("^This$", "This")); //True\par
   System.out.println(\par
     Pattern.matches("^This$", "Is This Chaitanya")); //False\par
\}\par
\}\par
\par
\par
\par
\par
Java Annotations tutorial with examples\par
 JAVA TUTORIALS\par
Java Annotations allow us to add metadata information into our source code, although they are not a part of the program itself. Annotations were added to the java from JDK 5. Annotation has no direct effect on the operation of the code they annotate (i.e. it does not affect the execution of the program).\par
\par
In this tutorial we are going to cover following topics: Usage of annotations, how to apply annotations, what predefined annotation types are available in the Java and how to create custom annotations.\par
\par
What\f1\rquote\f0 s the use of Annotations?\par
\par
1) Instructions to the compiler: There are three built-in annotations available in Java (@Deprecated, @Override & @SuppressWarnings) that can be used for giving certain instructions to the compiler. For example the @override annotation is used for instructing compiler that the annotated method is overriding the method. More about these built-in annotations with example is discussed in the next sections of this article.\par
\par
2) Compile-time instructors: Annotations can provide compile-time instructions to the compiler that can be further used by sofware build tools for generating code, XML files etc.\par
\par
3) Runtime instructions: We can define annotations to be available at runtime which we can access using java reflection and can be used to give instructions to the program at runtime. We will discuss this with the help of an example, later in this same post.\par
\par
Annotations basics\par
\par
An annotation always starts with the symbol @ followed by the annotation name. The symbol @ indicates to the compiler that this is an annotation.\par
\par
For e.g. @Override\par
Here @ symbol represents that this is an annotation and the Override is the name of this annotation.\par
\par
Where we can use annotations?\par
Annotations can be applied to the classes, interfaces, methods and fields. For example the below annotation is being applied to the method.\par
\par
@Override\par
void myMethod() \{ \par
    //Do something \par
\}\par
What this annotation is exactly doing here is explained in the next section but to be brief it is instructing compiler that myMethod() is a overriding method which is overriding the method (myMethod()) of super class.\par
\par
Built-in Annotations in Java\par
\par
Java has three built-in annotations:\par
\par
@Override\par
@Deprecated\par
@SuppressWarnings\par
1) @Override:\par
While overriding a method in the child class, we should use this annotation to mark that method. This makes code readable and avoid maintenance issues, such as: while changing the method signature of parent class, you must change the signature in child classes (where this annotation is being used) otherwise compiler would throw compilation error. This is difficult to trace when you haven\f1\rquote\f0 t used this annotation.\par
\par
Example:\par
\par
public class MyParentClass \{\par
\par
    public void justaMethod() \{\par
        System.out.println("Parent class method");\par
    \}\par
\}\par
\par
\par
public class MyChildClass extends MyParentClass \{\par
\par
    @Override\par
    public void justaMethod() \{\par
        System.out.println("Child class method");\par
    \}\par
\}\par
I believe the example is self explanatory. To read more about this annotation, refer this article: @Override built-in annotation.\par
\par
2) @Deprecated\par
@Deprecated annotation indicates that the marked element (class, method or field) is deprecated and should no longer be used. The compiler generates a warning whenever a program uses a method, class, or field that has already been marked with the @Deprecated annotation. When an element is deprecated, it should also be documented using the Javadoc @deprecated tag, as shown in the following example. Make a note of case difference with @Deprecated and @deprecated. @deprecated is used for documentation purpose.\par
\par
Example:\par
\par
/**\par
 * @deprecated\par
 * reason for why it was deprecated\par
 */\par
@Deprecated\par
public void anyMethodHere()\{\par
    // Do something\par
\}\par
Now, whenever any program would use this method, the compiler would generate a warning. To read more about this annotation, refer this article: Java \f1\endash  \f0 @Deprecated annotation.\par
\par
3) @SuppressWarnings\par
This annotation instructs compiler to ignore specific warnings. For example in the below code, I am calling a deprecated method (lets assume that the method deprecatedMethod() is marked with @Deprecated annotation) so the compiler should generate a warning, however I am using @@SuppressWarnings annotation that would suppress that deprecation warning.\par
\par
@SuppressWarnings("deprecation")\par
    void myMethod() \{\par
        myObject.deprecatedMethod();\par
\}\par
Creating Custom Annotations\par
\par
Annotations are created by using @interface, followed by annotation name as shown in the below example.\par
An annotation can have elements as well. They look like methods. For example in the below code, we have four elements. We should not provide implementation for these elements.\par
All annotations extends java.lang.annotation.Annotation interface. Annotations cannot include any extends clause.\par
import java.lang.annotation.Documented;\par
import java.lang.annotation.ElementType;\par
import java.lang.annotation.Inherited;\par
import java.lang.annotation.Retention;\par
import java.lang.annotation.RetentionPolicy;\par
import java.lang.annotation.Target;\par
 \par
@Documented\par
@Target(ElementType.METHOD)\par
@Inherited\par
@Retention(RetentionPolicy.RUNTIME)\par
public @interface MyCustomAnnotation\{\par
    int studentAge() default 18;\par
    String studentName();\par
    String stuAddress();\par
    String stuStream() default "CSE";\par
\}\par
Note: All the elements that have default values set while creating annotations can be skipped while using annotation. For example if I\f1\rquote\f0 m applying the above annotation to a class then I would do it like this:\par
\par
@MyCustomAnnotation(\par
    studentName="Chaitanya",\par
    stuAddress="Agra, India"\par
)\par
public class MyClass \{\par
...\par
\}\par
As you can see, we have not given any value to the studentAge and stuStream elements as it is optional to set the values of these elements (default values already been set in Annotation definition, but if you want you can assign new value while using annotation just the same way as we did for other elements). However we have to provide the values of other elements (the elements that do not have default values set) while using annotation.\par
\par
Note: We can also have array elements in an annotation. This is how we can use them:\par
Annotation definition:\par
\par
@interface MyCustomAnnotation \{\par
    int      count();\par
    String[] books();\par
\}\par
Usage:\par
\par
@MyCustomAnnotation(\par
    count=3,\par
    books=\{"C++", "Java"\}\par
)\par
public class MyClass \{\par
\par
\}\par
Lets back to the topic again: In the custom annotation example we have used these four annotations: @Documented, @Target, @Inherited & @Retention. Lets discuss them in detail.\par
\par
@Documented\par
@Documented annotation indicates that elements using this annotation should be documented by JavaDoc. For example:\par
\par
java.lang.annotation.Documented\par
@Documented\par
public @interface MyCustomAnnotation \{\par
  //Annotation body\par
\}\par
@MyCustomAnnotation\par
public class MyClass \{ \par
     //Class body\par
\}\par
While generating the javadoc for class MyClass, the annotation @MyCustomAnnotation would be included in that.\par
\par
@Target\par
It specifies where we can use the annotation. For example: In the below code, we have defined the target type as METHOD which means the below annotation can only be used on methods.\par
\par
import java.lang.annotation.ElementType;\par
import java.lang.annotation.Target;\par
\par
@Target(\{ElementType.METHOD\})\par
public @interface MyCustomAnnotation \{\par
\par
\}\par
public class MyClass \{\par
   @MyCustomAnnotation\par
   public void myMethod()\par
   \{\par
       //Doing something\par
   \}\par
\}\par
Note: 1) If you do not define any Target type that means annotation can be applied to any element.\par
2) Apart from ElementType.METHOD, an annotation can have following possible Target values.\par
ElementType.METHOD\par
ElementType.PACKAGE\par
ElementType.PARAMETER\par
ElementType.TYPE\par
ElementType.ANNOTATION_TYPE\par
ElementType.CONSTRUCTOR\par
ElementType.LOCAL_VARIABLE\par
ElementType.FIELD\par
\par
@Inherited\par
The @Inherited annotation signals that a custom annotation used in a class should be inherited by all of its sub classes. For example:\par
\par
java.lang.annotation.Inherited\par
\par
@Inherited\par
public @interface MyCustomAnnotation \{\par
\par
\}\par
@MyCustomAnnotation\par
public class MyParentClass \{ \par
  ... \par
\}\par
public class MyChildClass extends MyParentClass \{ \par
   ... \par
\}\par
Here the class MyParentClass is using annotation @MyCustomAnnotation which is marked with @inherited annotation. It means the sub class MyChildClass inherits the @MyCustomAnnotation.\par
\par
@Retention\par
It indicates how long annotations with the annotated type are to be retained.\par
\par
import java.lang.annotation.Retention;\par
import java.lang.annotation.RetentionPolicy;\par
\par
@Retention(RetentionPolicy.RUNTIME)\par
@interface MyCustomAnnotation \{\par
    \par
\}\par
Here we have used RetentionPolicy.RUNTIME. There are two other options as well. Lets see what do they mean:\par
RetentionPolicy.RUNTIME: The annotation should be available at runtime, for inspection via java reflection.\par
RetentionPolicy.CLASS: The annotation would be in the .class file but it would not be available at runtime.\par
RetentionPolicy.SOURCE: The annotation would be available in the source code of the program, it would neither be in the .class file nor be available at the runtime.\par
\par
That\f1\rquote\f0 s all for this topic \f1\ldblquote\f0 Java Annotation\f1\rdblquote\f0 . Should you have any questions, feel free to drop a line below.\par
\par
@Deprecated annotation in java\par
 JAVA TUTORIALS\par
@Deprecated annotation is used for informing compiler that the particular method, class or field is deprecated and it should generate a warning when someone try to use any of the them.\par
\par
What is the meaning of \f1\ldblquote\f0 Deprecated\f1\rdblquote\f0 ?\par
A deprecated class or method is like that. It is no longer important. It is so unimportant, in fact, that you should no longer use it, since it has been superseded and may cease to exist in the future.\par
\par
Java provides a way to express deprecation because, as a class evolves, its API (application programming interface) inevitably changes: methods are renamed for consistency, new and better methods are added, and fields change. But such changes introduce a problem. You need to keep the old API around until developers make the transition to the new one, but you don\f1\rquote\f0 t want them to continue programming to the old API, in such case you can deprecate the particular item using built-in annotation. Source.\par
\par
How to Deprecate?\par
We deprecate a method, class or field by using @Deprecated annotation and we use @deprecated Javadoc tag in the comment section to inform the developer, the reason of deprecation and what can be used in place of this deprecated method, class or field. Lets take an example:\par
\par
Example\par
class DeprecatedDemo \{\par
   /* @deprecated This field is replaced by \par
    * MAX_NUM field\par
    */\par
   @Deprecated\par
   int num=10;\par
\tab\par
   final int MAX_NUM=10;\par
    \par
   /* @deprecated As of release 1.5, replaced \par
    * by myMsg2(String msg, String msg2)\par
    */\par
   @Deprecated\par
   public void myMsg()\{\par
       System.out.println("This method is marked as deprecated");\par
   \}\par
     \par
   public void myMsg2(String msg, String msg2)\{\par
       System.out.println(msg+msg2);\par
   \}\par
    \par
   public static void main(String a[])\{      \par
    \tab DeprecatedDemo obj = new DeprecatedDemo();\par
        obj.myMsg();\par
        System.out.println(obj.num);\par
   \}\par
\}\par
Output:\par
\par
This method is marked as deprecated\par
10\par
In the above example we have a deprecated method and a deprecated field. As you can see that we have marked both of them using @Deprecated annotation and in the comment section we have used @deprecated javadoc tag (for documentation purpose) to inform the programmer what to use in place of it.\par
\par
Note: When you use deprecated types(method, class or field) the compiler would not throw a compilation error it would just show a warning to let you know that this is deprecated and you may have a better alternative of it, which you can find out in the comments section by looking for @deprecated tag.\par
\par
@Override annotation in Java\par
 JAVA TUTORIALS\par
@Override annotation is used when we override a method in sub class. Generally novice developers overlook this feature as it is not mandatory to use this annotation while overriding the method. Here we will discuss why we should use @Override annotation and why it is considered as a best practice in java coding.\par
\par
Lets take an example first to understand how it is used then we will discuss it in detail:\par
\par
Example\par
class ParentClass\par
\{\par
\tab public void displayMethod(String msg)\{\par
\tab\tab System.out.println(msg);\par
\tab\}\par
\}\par
class SubClass extends ParentClass\par
\{\par
\tab @Override\par
\tab public void displayMethod(String msg)\{\par
\tab\tab System.out.println("Message is: "+ msg);\par
\tab\}\par
\tab public static void main(String args[])\{\par
\tab\tab SubClass obj = new SubClass();\par
\tab\tab obj.displayMethod("Hey!!");\par
\tab\}\par
\}\par
In the above example we are overriding a method displaymethod() in the child class. Even if we don\f1\rquote\f0 t use the @Override annotation, the program would still run fine without any issues, You would be wondering the why do we use this annotation at all. Lets discuss about it:\par
\par
Why we use @Override annotation\par
Using @Override annotation while overriding a method is considered as a best practice for coding in java because of the following two advantages:\par
\par
1) If programmer makes any mistake such as wrong method name, wrong parameter types while overriding, you would get a compile time error. As by using this annotation you instruct compiler that you are overriding this method. If you don\f1\rquote\f0 t use the annotation then the sub class method would behave as a new method (not the overriding method) in sub class.\par
\par
2) It improves the readability of the code. So if you change the signature of overridden method then all the sub classes that overrides the particular method would throw a compilation error, which would eventually help you to change the signature in the sub classes. If you have lots of classes in your application then this annotation would really help you to identify the classes that require changes when you change the signature of a method.\par
\par
\par
Java Autoboxing and Unboxing with examples\par
 JAVA TUTORIALS\par
Java 1.5 introduced a special feature of auto conversion of primitive types to the corresponding Wrapper class and vice versa.\par
\par
Autoboxing: Automatic conversion of primitive types to the object of their corresponding wrapper classes is known as autoboxing. For example \f1\endash  \f0 conversion of int to Integer, long to Long, double to Double etc.\par
\par
Unboxing: It is just the reverse process of autoboxing. Automatically converting an object of a wrapper class to its corresponding primitive type is known as unboxing. For example \f1\endash  \f0 conversion of Integer to int, Long to long, Double to double etc.\par
\par
Primitive type\tab Wrapper class\par
boolean\tab         Boolean\par
byte\tab         Byte\par
char\tab         Character\par
float\tab         Float\par
int\tab         Integer\par
long\tab         Long\par
short\tab         Short\par
double\tab         Double\par
When does the autoboxing and unboxing happens in Java\par
\par
Autoboxing\par
: Lets see few cases with examples, where autoboxing happens.\par
Case 1: When a method is expecting a wrapper class object but the value that is passed as parameter is a primitive type. For example in the below code, the method myMethod() is expecting an object of Integer wrapper class, however we passed a primitive int type. The program ran fine as compiler does the autoboxing (conversion of int to Integer)\par
\par
class AutoboxingExample1\par
\{\par
   public static void myMethod(Integer num)\{\par
\tab System.out.println(num);\par
   \}\par
   public static void main(String[] args) \{\par
       /* passed int (primitive type), it would be \par
        * converted to Integer object at Runtime\par
        */\par
   \tab myMethod(2);\par
   \}\par
\}\par
Output:\par
\par
2\par
Case 2: When at some point of time, you are assigning a primitive type value to an object of its wrapper class. For example: The below statements are valid because compiler does the autoboxing at runtime.\par
\par
Integer inum = 3; //Assigning int to Integer: Autoboxing\par
Long lnum = 32L; //Assigning long to Long: Autoboxing\par
Case 3: When dealing with collection framework classes:\par
\par
ArrayList<Integer> arrayList = new ArrayList<Integer>();\par
arrayList.add(11); //Autoboxing - int primitive to Integer\par
arrayList.add(22); //Autoboxing\par
Here ArrayList class is expecting an Integer wrapper class object but we are providing int primitive.\par
\par
Unboxing\par
Case 1: Method is expecting Integer object (parameter) but we have supplied int. Auotmatic conversion(unboxing) happened that converted Integer to int.\par
\par
class UnboxingExample1\par
\{\par
   public static void myMethod(int num)\{\par
\tab System.out.println(num);\par
   \}\par
   public static void main(String[] args) \{\par
    \tab\par
    \tab Integer inum = new Integer(100);\par
    \tab\par
        /* passed Integer wrapper class object, it \par
         * would be converted to int primitive type \par
         * at Runtime\par
         */\par
    \tab myMethod(inum);\par
    \}\par
\}\par
Output:\par
\par
100\par
Case 2: Assignments\par
\par
Integer inum = new Integer(5);\par
int num = inum; //unboxing object to primitive conversion\par
Case 3: While dealing with collection classes:\par
\par
ArrayList arrayList = new ArrayList()\par
int num = arrayList.get(0); // unboxing because get method returns an Integer object\par
What happens behind the scenes?\par
\par
In the above section we learnt how java compiler performs automatic conversion between primitive type and corresponding Wrapper objects. Lets discuss what compiler actually does during autoboxing and unboxing. The best way to understand this is to compare things before java 1.5 and after java 1.5 (boxing and unboxing introduced in java 1.5).\par
\par
Autoboxing:\par
What we see:\par
\par
Integer number = 100;\par
What compiler does (or what we used to do before java 1.5):\par
\par
Integer number = Integer.valueOf(100);\par
Unboxing:\par
What we see:\par
\par
Integer num2 = new Integer(50);\par
int inum = num2;\par
What compiler does:\par
\par
Integer num2 = new Integer(50);\par
int inum = num2.intValue();\par
Similar things happen with the other wrapper classes and primitive types such as long, double, short etc.\par
\par
Few things you should take care:\par
Do not mix primitives and objects while doing comparisons. You might get unpredictable results for such comparisons. Better thing to do is: compare object with objects (using equals() method) and compare primitive with primitives(using logical operators such as \f1\ldblquote\f0 ==\f1\rdblquote\f0 , \f1\ldblquote\f0 <\f1\rdblquote  \f0 etc).\par
\par
\par
Java Tutorial \f1\endash  \f0 Compilation and Execution of First Java Program\par
 JAVA TUTORIALS\par
To create a java code an editor such as notepad, text pad or an IDE like eclipse can be used.\par
\par
Sample Java Code:\par
\par
public class FirstJavaProgram \{\par
  public static void main(String[] args)\{\par
    System.out.println("This is my first program in java");\par
  \}//End of main\par
\}//End of FirstJavaProgram Class\par
Output: This is my first program in java\par
\par
In the above program the class FirstJavaProgram has public access and hence declared public.\par
\f1\lquote\f0 class\f1\rquote  \f0 is the keyword used to create a class.\par
For running stand-alone programs \f1\lquote\f0 main\f1\rquote  \f0 method is needed which has a signature similar to the one defined in the above program.\par
\f1\lquote\f0 Main\f1\rquote  \f0 method takes an array of strings as an argument. The name of the array can be anything.\par
To display the output, pass the string as an argument to the method System.out.println.\par
Steps for compilation and Execution\par
\par
Step1: Save the source file as WelcomeApp.java.\par
Step2: Open command prompt and navigate to the directory where you have stored the file.\par
Step 3: To compile, type javac FirstJavaProgram.java and press Enter.\par
Step 4: On successful compilation, you will see the command prompt and FirstJavaProgram.class file in the same folder where WelcomeApp.java is stored. This is the byte code of the program.\par
Step 5: To execute, type java FirstJavaProgram. Do not type the extension while executing.\par
Step 6: See the output \f1\ldblquote\f0 This is my first program in java\f1\rdblquote  \f0 displayed on the console.\par
\par
Common programming Errors in Java\par
\par
The following are the general programming errors and the solution for them while running on windows machine.\par
\par
1) \f1\lquote\f0 javac\f1\rquote  \f0 is not recognized as an internal or external command, operable program or batch file \f1\endash  \f0 This means that the operating system cannot find the compiler \f1\endash  \f0 javac.  In order to resolve this the PATH variable has to be set.\par
2) Exception in thread \f1\ldblquote\f0 main\f1\rdblquote\f0 java.lang.NoClassDefFoundError: FirstJavaProgram \f1\endash   \f0 This error means that java cannot find your compiled byte code, WelcomeApp.class. If the class file is present in directory other than the directory where java file is stored, then the CLASSPATH must be set pointing to the directory that contains compiled class files.\par
\par
Another Example\par
\par
If you are a beginner and feel hard to understand the below example then just skip it and try to understand it once you finished reading all of my linked tutorials. After reading all tutorials it would be easy for you to learn things much faster.\par
\par
package FirstCode\par
import java.lang.*;\par
class WelcomeMessage\par
\{\par
  printMessage()\par
  \{\par
      System.out.println("Hello World");\par
  \}\par
\}\par
class Myclass\par
\{\par
   public static void main(String  []args)\par
   \{\par
      WelcomeMessage obj=new  WelcomeMessage ();\par
      obj.printMessage();\par
   \}\par
\}\par
Output: Hello World\par
\par
Interpreting the code\par
a) Line 1. The package FirstCode creates a folder to store the class files generated after compilation\par
b) Line2. It imports the class library java.lang and its subsequent classes\par
c) Line 3. Initiates a class with the name WelcomeMessage\par
d) Line 5. Declares a method with name printMessage\par
e) Line 7. Defines the actual working code of the method\par
f) Line 10. Initiates the class having the main method; it should bear the name of the file : Myclass.java\par
g) Line 12. Declares the main method\par
h) Line 14. Initiates the creation of the object\par
i) Line 15. Calls the method printMessage () with the help of the object\par
j) The above code is saved and compiled to run on JVM\par
\par
The programming structure\par
1) The programming pattern is divided into classes which has meth0d definitions\par
2) This assists in distributing the code into smaller units\par
3) The libraries can be used over and over again\par
4) These codes generated here can be called in another program if required\par
5) The memory allocation is done only after the execution of the new keyword\par
6) It gets easier to collect memory that does not has any future use\par
\par
\par
Java Tutorial \f1\endash  \f0 JVM (Java virtual Machine)\par
 JAVA TUTORIALS\par
JVM - java virtual machine\par
1) Class loader accepts class files\par
2) Compilation creates class files\par
3) The interim memory is required during execution\par
4) It consists of heaps, stacks and registers to store data\par
5) JRE has native methods and libraries\par
6) JVM runs two main threads\par
a) demon\par
b) Non-demon threads\par
\par
Demon Threads\par
It has been Run by JVM for itself. Used for garbage collection. JVM decides on a thread for being a demon thread\par
\par
Non-demon threads\par
main() is the initial and non-demon thread. Other implemented threads are also non-demon threads. The JVM is active till any non-demon thread is active.\par
\par
Execution on JVM\par
\par
1) JVM executes Java byte codes\par
2) Other programming language codes if converted to adequate Java byte code can be executed on JVM\par
3) JVM is different for different platforms and can also act as a platform itself\par
4) JVM supports automatic  error handling by  intercepting the errors which can be controlled\par
5) This feature is useful in platform independency and multi user ability of Java.\par
\par
Compilation\par
\par
1) The compiler requires to know the TYPE of every CLASS used in the program source code\par
2) This is done by setting a default user environment variable CLASSPATH\par
3) The Javac (Java Compiler) reads the program and converts it into byte code files called as class files\par
\par
java-compiler-javac\par
\par
Java Source code\par
1) It essentially consists of a main() method\par
2) This method is public and thus can be called by any object\par
3) This method is also static and so can be called without instantiating the object of the class\par
4) It does not return any value\par
5) The controlling class of every Java application usually contain a main method\par
6) This can be avoided to allow the class to be tested in a stand-alone mode.\par
7) Other methods can subsequently be called in main()\par
\par
\par
How to override toString method for ArrayList in Java\par
 JAVA COLLECTIONS\par
When we are dealing with ArrayList of Objects then it is must to Override the toString() method in order to get the output in desired format. In this tutorial we will see how to override the toString() method for ArrayList in Java.\par
\par
Example:\par
We have two classes here \f1\ldblquote\f0 Student\f1\rdblquote  \f0 and \f1\ldblquote\f0 Demo\f1\rdblquote\f0 . Student class has only two properties student name and student age. As you can see that we have overridden the toString() method in Student class itself. In the Demo class we are storing the Student Object in ArrayList and then we iterated the ArrayList using advance for loop. You can very well see that the output is in the format we have specified in toString(). You can give the toString() coding as per your requirement.\par
\par
package beginnersbook.com;\par
public class Student \par
\{\par
    private String studentname;\par
    private int studentage;\par
    Student(String name, int age)\par
    \{\par
         this.studentname=name;\par
         this.studentage=age;\par
    \}\par
    @Override\par
    public String toString() \{\par
       return "Name is: "+this.studentname+" & Age is: "+this.studentage;\par
    \}\par
\}\par
Another class:\par
\par
package beginnersbook.com;\par
import java.util.ArrayList;\par
public class Demo\par
\{\par
     public static void main(String [] args)\par
     \{\par
          ArrayList<Student> al= new ArrayList<Student>();\par
          al.add(new Student("Chaitanya", 26));\par
          al.add(new Student("Ajeet", 25));\par
          al.add(new Student("Steve", 55));\par
          al.add(new Student("Mary", 18));\par
          al.add(new Student("Dawn", 22));\par
          for (Student tmp: al)\{\par
              System.out.println(tmp);\par
          \}\par
     \}\par
\}\par
Output:\par
\par
Name is: Chaitanya & Age is: 26\par
Name is: Ajeet & Age is: 25\par
Name is: Steve & Age is: 55\par
Name is: Mary & Age is: 18\par
Name is: Dawn & Age is: 22\par
If we wouldn\f1\rquote\f0 t have overridden the toString() we would have got the output in below format:\par
Output of the above programs without overriding toString():\par
\par
beginnersbook.com.Student@10b28f30\par
beginnersbook.com.Student@3ad6a0e0\par
beginnersbook.com.Student@60dbf04d\par
beginnersbook.com.Student@77d80e9\par
beginnersbook.com.Student@409a44d6\par
\par
Java ArrayList of Object Sort Example (Comparable And Comparator)\par
 JAVA COLLECTIONS\par
In this tutorial we will see how to sort an ArrayList of Objects by property using comparable and comparator interface. If you are looking for sorting a simple ArrayList of String or Integer then you may like to refer the following tutorials \f1\endash\par
\par
\f0 Sorting of ArrayList<String> and ArrayList<Integer>\par
Sorting of ArrayList in descending order\par
We generally use Collections.sort() method to sort a simple array list. However if the ArrayList is of custom object type then in such case you have two options for sorting- comparable and comparator interfaces. Before going through the example of them, let\f1\rquote\f0 s see what\f1\rquote\f0 s the output when we try to sort arraylist of Objects without implementing any of these interfaces.\par
\par
What\f1\rquote\f0 s the need of comparable and comparator?\par
\par
Consider the below example \f1\endash  \f0 I have a Student class which has properties like Student name, roll no and student age.\par
\par
public class Student  \{\par
    private String studentname;\par
    private int rollno;\par
    private int studentage;\par
\par
    public Student(int rollno, String studentname, int studentage) \{\par
         this.rollno = rollno;\par
         this.studentname = studentname;\par
         this.studentage = studentage;\par
    \}\par
\par
    public String getStudentname() \{\par
         return studentname;\par
    \}\par
    public void setStudentname(String studentname) \{\par
\tab this.studentname = studentname;\par
    \}\par
    public int getRollno() \{\par
\tab return rollno;\par
    \}\par
    public void setRollno(int rollno) \{\par
\tab this.rollno = rollno;\par
    \}\par
    public int getStudentage() \{\par
\tab return studentage;\par
    \}\par
    public void setStudentage(int studentage) \{\par
 \tab this.studentage = studentage;\par
    \}\tab\par
\}\par
And I want to have an ArrayList of Student Object. We do it like this \f1\endash\f0\par
\par
import java.util.*;\par
public class ArrayListSorting  \{\par
\par
     public static void main(String args[])\{\par
\tab    ArrayList<Student> arraylist = new ArrayList<Student>();\par
\tab    arraylist.add(new Student(223, "Chaitanya", 26));\par
\tab    arraylist.add(new Student(245, "Rahul", 24));\par
\tab    arraylist.add(new Student(209, "Ajeet", 32));\par
\par
\tab    Collections.sort(arraylist);\par
\par
\tab    for(Student str: arraylist)\{\par
\tab\tab\tab System.out.println(str);\par
\tab    \}\par
     \}\par
\}\par
I tried to call the Collections.sort() on the List of Objects and boom! I got the the error message like this \f1\endash\f0\par
Exception in thread \f1\ldblquote\f0 main\f1\rdblquote  \f0 java.lang.Error: Unresolved compilation problem:\par
Bound mismatch: The generic method sort(List) of type Collections is not applicable for the arguments (ArrayList). The inferred type Student is not a valid substitute for the bounded parameter > at beginnersbook.com.Details.main(Details.java:11)\par
\par
Reason: I Just called the sort method on an ArrayList of Objects which actually doesn\f1\rquote\f0 t work until unless we use interfaces like Comparable and Comparator.\par
\par
Now you must have understood the importance of these interfaces. Let\f1\rquote\f0 s see how to use them to get the sorting done in our way.\par
\par
Sorting of ArrayList<Object> with Comparable\par
\par
Let\f1\rquote\f0 s say we need to sort the ArrayList<Student> based on the student Age property. This is how it can be done \f1\endash  \f0 First implement Comparable interface and then Override the compareTo method.\par
\par
package beginnersbook.com;\par
\par
public class Student implements Comparable \{\par
    private String studentname;\par
    private int rollno;\par
    private int studentage;\par
\par
    public Student(int rollno, String studentname, int studentage) \{\par
        this.rollno = rollno;\par
        this.studentname = studentname;\par
        this.studentage = studentage;\par
    \}\par
    ...\par
    //getter and setter methods same as the above example \par
    ...\par
    @Override\par
    public int compareTo(Student comparestu) \{\par
        int compareage=((Student)comparestu).getStudentage();\par
        /* For Ascending order*/\par
        return this.studentage-compareage;\par
\par
        /* For Descending order do like this */\par
        //return compareage-this.studentage;\par
    \}\par
\par
    @Override\par
    public String toString() \{\par
        return "[ rollno=" + rollno + ", name=" + studentname + ", age=" + studentage + "]";\par
    \}\par
\par
\}\par
Now we can very well call Collections.sort on ArrayList\par
\par
import java.util.*;\par
public class ArrayListSorting  \{\par
\par
\tab public static void main(String args[])\{\par
\tab    ArrayList<Student> arraylist = new ArrayList<Student>();\par
\tab    arraylist.add(new Student(223, "Chaitanya", 26));\par
\tab    arraylist.add(new Student(245, "Rahul", 24));\par
\tab    arraylist.add(new Student(209, "Ajeet", 32));\par
\par
\tab    Collections.sort(arraylist);\par
\par
\tab    for(Student str: arraylist)\{\par
\tab\tab\tab System.out.println(str);\par
\tab    \}\par
\tab\}\par
\}\par
Output:\par
\par
[ rollno=245, name=Rahul, age=24]\par
[ rollno=223, name=Chaitanya, age=26]\par
[ rollno=209, name=Ajeet, age=32]\par
Comparable did our job why do we need Comparator anymore?\par
Using Comparable we can sort only a single property which should be of an integer type. In order to sort the ArrayList based on multiple properties we can use Comparator.\par
\par
Sorting ArrayList<Object> multiple properties with Comparator\par
\par
We are overriding compare method of Comparator for sorting.\par
\par
package beginnersbook.com;\par
import java.util.Comparator;\par
public class Student  \{\par
    private String studentname;\par
    private int rollno;\par
    private int studentage;\par
\par
    public Student(int rollno, String studentname, int studentage) \{\par
        this.rollno = rollno;\par
        this.studentname = studentname;\par
        this.studentage = studentage;\par
    \}\par
    ...\par
    //Getter and setter methods same as the above examples\par
    ...\par
    /*Comparator for sorting the list by Student Name*/\par
    public static Comparator<Student> StuNameComparator = new Comparator<Student>() \{\par
\par
\tab public int compare(Student s1, Student s2) \{\par
\tab    String StudentName1 = s1.getStudentname().toUpperCase();\par
\tab    String StudentName2 = s2.getStudentname().toUpperCase();\par
\par
\tab    //ascending order\par
\tab    return StudentName1.compareTo(StudentName2);\par
\par
\tab    //descending order\par
\tab    //return StudentName2.compareTo(StudentName1);\par
    \}\};\par
\par
    /*Comparator for sorting the list by roll no*/\par
    public static Comparator<Student> StuRollno = new Comparator<Student>() \{\par
\par
\tab public int compare(Student s1, Student s2) \{\par
\par
\tab    int rollno1 = s1.getRollno();\par
\tab    int rollno2 = s2.getRollno();\par
\par
\tab    /*For ascending order*/\par
\tab    return rollno1-rollno2;\par
\par
\tab    /*For descending order*/\par
\tab    //rollno2-rollno1;\par
   \}\};\par
    @Override\par
    public String toString() \{\par
        return "[ rollno=" + rollno + ", name=" + studentname + ", age=" + studentage + "]";\par
    \}\par
\par
\}\par
ArrayList class:\par
\par
package beginnersbook.com;\par
import java.util.*;\par
public class Details  \{\par
\par
\tab public static void main(String args[])\{\par
\tab    ArrayList<Student> arraylist = new ArrayList<Student>();\par
\tab    arraylist.add(new Student(101, "Zues", 26));\par
\tab    arraylist.add(new Student(505, "Abey", 24));\par
\tab    arraylist.add(new Student(809, "Vignesh", 32));\par
\par
\tab    /*Sorting based on Student Name*/\par
\tab    System.out.println("Student Name Sorting:");\par
\tab    Collections.sort(arraylist, Student.StuNameComparator);\par
\par
\tab    for(Student str: arraylist)\{\par
\tab\tab\tab System.out.println(str);\par
\tab    \}\par
\par
\tab    /* Sorting on Rollno property*/\par
\tab    System.out.println("RollNum Sorting:");\par
\tab    Collections.sort(arraylist, Student.StuRollno);\par
\tab    for(Student str: arraylist)\{\par
\tab\tab\tab System.out.println(str);\par
\tab    \}\par
\tab\}\par
\}\par
Output:\par
\par
Student Name Sorting:\par
[ rollno=505, name=Abey, age=24]\par
[ rollno=809, name=Vignesh, age=32]\par
[ rollno=101, name=Zues, age=26]\par
RollNum Sorting:\par
[ rollno=101, name=Zues, age=26]\par
[ rollno=505, name=Abey, age=24]\par
[ rollno=809, name=Vignesh, age=32]\par
\par
Java ArrayList trimToSize() Method example\par
 JAVA COLLECTIONS\par
trimToSize() method is used for memory optimization. It trims the capacity of ArrayList to the current list size. For e.g. An arraylist is having capacity of 15 but there are only 5 elements in it, calling trimToSize() method on this ArrayList would change the capacity from 15 to 5.\par
\par
public void trimToSize()\par
\par
Example\par
\par
Here I have defined the ArrayList of capacity 50. After adding 10 elements I called trimToSize() method which would have reduced the capacity from 50 to 10 (current size of arraylist).\par
\par
package beginnersbook.com;\par
import java.util.ArrayList;\par
public class TrimExample \{\par
  public static void main(String args[]) \{\par
    ArrayList<Integer> arraylist = new ArrayList<Integer>(50);\par
    arraylist.add(1);\par
    arraylist.add(2);\par
    arraylist.add(3);\par
    arraylist.add(4);\par
    arraylist.add(5);\par
    arraylist.add(6);\par
    arraylist.add(7);\par
    arraylist.add(1);\par
    arraylist.add(1);\par
    arraylist.add(1);\par
    arraylist.trimToSize();\par
    System.out.println(arraylist);\par
  \}\par
\}\par
Output:\par
\par
[1, 2, 3, 4, 5, 6, 7, 1, 1, 1]\par
\par
Java ArrayList set() Method example\par
 JAVA COLLECTIONS\par
If there is a need to update the list element based on the index then set method of ArrayList class can be used. The method set(int index, Element E) updates the element of specified index with the given element E.\par
\par
public E set(int index, Element E)\par
\par
Example:\par
\par
In this example I have an ArrayList of Integer Type where I have added few elements and then I\f1\rquote\f0 m updating few of elements using set method of java.util.ArrayList class.\par
\par
package beginnersbook.com;\par
import java.util.ArrayList;\par
public class SetExample \{\par
  public static void main(String args[]) \{\par
    ArrayList<Integer> arraylist = new ArrayList<Integer>();\par
    arraylist.add(1);\par
    arraylist.add(2);\par
    arraylist.add(3);\par
    arraylist.add(4);\par
    arraylist.add(5);\par
    arraylist.add(6);\par
    arraylist.add(7);\par
    System.out.println("ArrayList before update: "+arraylist);\par
    //Updating 1st element\par
    arraylist.set(0, 11);\par
    //Updating 2nd element\par
    arraylist.set(1, 22);\par
    //Updating 3rd element\par
    arraylist.set(2, 33);\par
    //Updating 4th element\par
    arraylist.set(3, 44);\par
    //Updating 5th element\par
    arraylist.set(4, 55);\par
    System.out.println("ArrayList after Update: "+arraylist);\par
  \}\par
\}\par
Output:\par
\par
ArrayList before update: [1, 2, 3, 4, 5, 6, 7]\par
ArrayList after Update: [11, 22, 33, 44, 55, 6, 7]\par
\par
Java ArrayList add() Method Example\par
 JAVA COLLECTIONS\par
Here we are discussing about add() method of Java.util.ArrayList class. This method is used for adding an element to the ArrayList. Below is the method signature:\par
\par
public boolean add(Object element)\par
\par
Example\par
\par
package beginnersbook.com;\par
import java.util.ArrayList;\par
public class Details \{\par
    public static void main(String[] args) \{\par
\par
        //ArrayList<String> Declaration\par
        ArrayList<String> al= new ArrayList<String>();\par
        //add method for String ArrayList\par
        al.add("Ram");\par
        al.add("Shyam");\par
        al.add("CPS");\par
        al.add("John");\par
        al.add("Steve");\par
        System.out.println("Elements of ArrayList of String Type: "+al);\par
\par
        //ArrayList<Integer> Declaration \par
        ArrayList<Integer> al2 = new ArrayList<Integer>();\par
        //add method for integer ArrayList\par
        al2.add(1);\par
        al2.add(34);\par
        al2.add(99);\par
        al2.add(99);\par
        al2.add(78);\par
        System.out.println("Elements of ArrayList of Integer Type: "+al2);\par
    \}\par
\}\par
Output:\par
\par
Elements of ArrayList of String Type: [Ram, Shyam, CPS, John, Steve]\par
Elements of ArrayList of Integer Type: [1, 34, 99, 99, 78]\par
\par
Java ArrayList get() Method example\par
 JAVA COLLECTIONS\par
ArrayList get(int index) method is used for fetching an element from the list. We need to specify the index while calling get method and it returns the value present at the specified index.\par
\par
public Element get(int index)\par
\par
This method throws IndexOutOfBoundsException if the index is less than zero or greater than the size of the list (index<0 OR index>= size of the list).\par
\par
Example\par
\par
In below example we are getting few elements of an arraylist by using get method.\par
\par
package beginnersbook.com;\par
import java.util.ArrayList;\par
public class GetMethodExample \{\par
   public static void main(String[] args) \{\par
       ArrayList<String> al = new ArrayList<String>();\par
       al.add("pen");\par
       al.add("pencil");\par
       al.add("ink");\par
       al.add("notebook");\par
       al.add("book");\par
       al.add("books");\par
       al.add("paper");\par
       al.add("white board");\par
\par
       System.out.println("First element of the ArrayList: "+al.get(0));\par
       System.out.println("Third element of the ArrayList: "+al.get(2));\par
       System.out.println("Sixth element of the ArrayList: "+al.get(5));\par
       System.out.println("Fourth element of the ArrayList: "+al.get(3));\par
   \}\par
\}\par
Output:\par
\par
First element of the ArrayList: pen\par
Third element of the ArrayList: ink\par
Sixth element of the ArrayList: books\par
Fourth element of the ArrayList: notebook\par
\par
How to override toString method for ArrayList in Java\par
 JAVA COLLECTIONS\par
When we are dealing with ArrayList of Objects then it is must to Override the toString() method in order to get the output in desired format. In this tutorial we will see how to override the toString() method for ArrayList in Java.\par
\par
Example:\par
We have two classes here \f1\ldblquote\f0 Student\f1\rdblquote  \f0 and \f1\ldblquote\f0 Demo\f1\rdblquote\f0 . Student class has only two properties student name and student age. As you can see that we have overridden the toString() method in Student class itself. In the Demo class we are storing the Student Object in ArrayList and then we iterated the ArrayList using advance for loop. You can very well see that the output is in the format we have specified in toString(). You can give the toString() coding as per your requirement.\par
\par
package beginnersbook.com;\par
public class Student \par
\{\par
    private String studentname;\par
    private int studentage;\par
    Student(String name, int age)\par
    \{\par
         this.studentname=name;\par
         this.studentage=age;\par
    \}\par
    @Override\par
    public String toString() \{\par
       return "Name is: "+this.studentname+" & Age is: "+this.studentage;\par
    \}\par
\}\par
Another class:\par
\par
package beginnersbook.com;\par
import java.util.ArrayList;\par
public class Demo\par
\{\par
     public static void main(String [] args)\par
     \{\par
          ArrayList<Student> al= new ArrayList<Student>();\par
          al.add(new Student("Chaitanya", 26));\par
          al.add(new Student("Ajeet", 25));\par
          al.add(new Student("Steve", 55));\par
          al.add(new Student("Mary", 18));\par
          al.add(new Student("Dawn", 22));\par
          for (Student tmp: al)\{\par
              System.out.println(tmp);\par
          \}\par
     \}\par
\}\par
\par
Java ArrayList get() Method example\par
 JAVA COLLECTIONS\par
ArrayList get(int index) method is used for fetching an element from the list. We need to specify the index while calling get method and it returns the value present at the specified index.\par
\par
public Element get(int index)\par
\par
This method throws IndexOutOfBoundsException if the index is less than zero or greater than the size of the list (index<0 OR index>= size of the list).\par
\par
Example\par
\par
In below example we are getting few elements of an arraylist by using get method.\par
\par
package beginnersbook.com;\par
import java.util.ArrayList;\par
public class GetMethodExample \{\par
   public static void main(String[] args) \{\par
       ArrayList<String> al = new ArrayList<String>();\par
       al.add("pen");\par
       al.add("pencil");\par
       al.add("ink");\par
       al.add("notebook");\par
       al.add("book");\par
       al.add("books");\par
       al.add("paper");\par
       al.add("white board");\par
\par
       System.out.println("First element of the ArrayList: "+al.get(0));\par
       System.out.println("Third element of the ArrayList: "+al.get(2));\par
       System.out.println("Sixth element of the ArrayList: "+al.get(5));\par
       System.out.println("Fourth element of the ArrayList: "+al.get(3));\par
   \}\par
\}\par
Output:\par
\par
First element of the ArrayList: pen\par
Third element of the ArrayList: ink\par
Sixth element of the ArrayList: books\par
Fourth element of the ArrayList: notebook\par
\par
Java ArrayList ensureCapacity() Method example\par
 JAVA COLLECTIONS\par
ArrayList internally implements growable dynamic array which means it can increase and decrease its size automatically. If we try to add an element to a already full ArrayList then it automatically re-sized internally to accommodate the new element however sometimes its not a good approach.\par
\par
Consider a scenario when there is a need to add huge number of elements to an already full ArrayList, in such case ArrayList has to be resized several number of times which would result in a poor performance. For such scenarios ensureCapacity() method of Java.util.ArrayList class is very useful as it increases the size of the ArrayList by a specified capacity.\par
\par
public void ensureCapacity(int minCapacity)\par
\par
Example\par
\par
package beginnersbook.com;\par
import java.util.ArrayList;\par
public class EnsureCapacityExample \{\par
  public static void main(String args[]) \{\par
      // ArrayList with Capacity 4\par
      ArrayList<String> al = new ArrayList<String>(4);\par
      //Added 4 elements\par
      al.add("Hi");\par
      al.add("Hello");\par
      al.add("Bye");\par
      al.add("GM");\par
\par
      //Increase capacity to 5\par
      al.ensureCapacity(55);\par
\par
      al.add("GE");\par
      // let us print all the elements available in list\par
      for (String temp: al) \{\par
            System.out.println(temp);\par
      \}\par
   \}\par
\}\par
Output:\par
\par
Hi\par
Hello\par
Bye\par
GM\par
GE\par
\par
Java ArrayList contains() Method example\par
 JAVA COLLECTIONS\par
ArrayList contains() method is used for checking the specified element existence in the given list.\par
\par
public boolean contains(Object element)\par
\par
It returns true if the specified element is found in the list else it gives false.\par
\par
Example\par
\par
In this example we have two array lists (ArrayList<String> and ArrayList<Integer>) and we are checking the existence of few elements in both the lists.\par
\par
package beginnersbook.com;\par
import java.util.ArrayList;\par
public class ContainsExample \{\par
   public static void main(String[] args) \{\par
\par
      ArrayList<String> al = new ArrayList<String>();\par
      al.add("pen");\par
      al.add("pencil");\par
      al.add("ink");\par
      al.add("notebook");\par
\par
      System.out.println("ArrayList contains the string 'ink pen': "\par
                                           +al.contains("ink pen"));\par
      System.out.println("ArrayList contains the string 'pen': "\par
                                             +al.contains("pen"));\par
      System.out.println("ArrayList contains the string 'pencil': "\par
                                          +al.contains("pencil"));\par
      System.out.println("ArrayList contains the string 'book': "\par
                                           +al.contains("book"));\par
\par
      ArrayList<Integer> al2 = new ArrayList<Integer>();\par
      al2.add(1);\par
      al2.add(99);\par
      al2.add(56);\par
      al2.add(13);\par
      al2.add(44);\par
      al2.add(6);\par
\par
      System.out.println("'1' is present in arraylist: "+al2.contains(1));\par
      System.out.println("'55' is present in arraylist: "+al2.contains(55));\par
      System.out.println("'44' is there in arraylist: "+al2.contains(44));\par
      System.out.println("'7' is there in arraylist: "+al2.contains(7));\par
   \}\par
\}\par
Output:\par
\par
ArrayList contains the string 'ink pen': false\par
ArrayList contains the string 'pen': true\par
ArrayList contains the string 'pencil': true\par
ArrayList contains the string 'book': false\par
'1' is present in arraylist: true\par
'55' is present in arraylist: false\par
'44' is there in arraylist: true\par
'7' is there in arraylist: false\par
}
 